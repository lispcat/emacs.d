#+TITLE: Emacs Configuration
#+STARTUP: content
#+PROPERTY: header-args :tangle config.el :comments link
#+auto_tangle: t

* Table of Contents :TOC_3:
- [[#to-add][to add]]
- [[#early-initel][early-init.el]]
- [[#initel][init.el]]
- [[#sane-defs][Sane Defs]]
- [[#package-manager][Package Manager]]
- [[#setupel][setup.el]]
  - [[#setc][setc]]
  - [[#global][:global]]
  - [[#autoload][:autoload]]
  - [[#quit][:quit]]
  - [[#with-local-quit][:with-local-quit]]
  - [[#load-after][:load-after]]
  - [[#unhook][:unhook]]
  - [[#local-unhook][:local-unhook]]
  - [[#advice][:advice]]
  - [[#advice-def][:advice-def]]
  - [[#load-from][:load-from]]
  - [[#diminish][:diminish]]
  - [[#option-shorthand][:option* (shorthand)]]
  - [[#doc][:doc]]
  - [[#pkg][:pkg]]
  - [[#catch-errors-throw-warnings][catch errors, throw warnings]]
  - [[#benchmark-all][benchmark all]]
  - [[#require-self][:require-self]]
  - [[#hook-into-all][:hook-into-all]]
- [[#necessary-packages][Necessary Packages]]
  - [[#no-littering][No Littering]]
  - [[#exec-path-from-shell][Exec-path-from-shell]]
  - [[#general][General]]
  - [[#diminish-1][Diminish]]
  - [[#which-key][Which-key]]
  - [[#hydra][Hydra]]
  - [[#dash][Dash]]
  - [[#f][f]]
  - [[#s][s]]
  - [[#consult][Consult]]
    - [[#consult-dir][Consult-dir]]
    - [[#leader-s][leader-s]]
- [[#startup-hooks][startup hooks]]
- [[#log][log]]
- [[#buffers][Buffers]]
  - [[#autorevert][autorevert]]
  - [[#auto-sudoedit][auto-sudoedit]]
  - [[#buttonize-urls][buttonize urls]]
  - [[#leader-b][leader-b]]
  - [[#leader-k][leader-k]]
- [[#history][History]]
- [[#windows][Windows]]
  - [[#ace-window][Ace-window]]
  - [[#hydra-window][hydra-window]]
  - [[#leader-w][leader-w]]
- [[#files][Files]]
  - [[#dired][Dired]]
  - [[#leader-fd][leader-f/d]]
- [[#misc][Misc]]
  - [[#helpful][Helpful]]
  - [[#tldr][tldr]]
  - [[#leader-d-profiling][leader-D (profiling)]]
  - [[#user][user]]
- [[#keyboard][Keyboard]]
  - [[#quality-of-life][quality of life]]
  - [[#meow][Meow]]
  - [[#avy][Avy]]
  - [[#jinx---todo-move][Jinx - TODO: move]]
  - [[#fontawesome---todo-move][Fontawesome - TODO: move]]
- [[#completion][Completion]]
  - [[#ui][UI]]
    - [[#vertico][Vertico]]
    - [[#candidate-icons][Candidate icons]]
    - [[#marginalia][Marginalia]]
  - [[#orderless-completion-style][Orderless (completion style)]]
  - [[#embark-minibuffer-actions][Embark (minibuffer actions)]]
    - [[#consult-integration][consult integration]]
  - [[#in-buffer-completion][in-buffer completion]]
    - [[#corfu][Corfu]]
    - [[#company-disabled][Company (Disabled)]]
  - [[#templates][templates]]
    - [[#tempel][Tempel]]
    - [[#yasnippet-disabled][Yasnippet (Disabled)]]
  - [[#cape][Cape]]
  - [[#hippie-expand][Hippie-expand]]
  - [[#isearch-todo-move][Isearch (TODO: move)]]
- [[#ide-rewrite-wip][IDE (rewrite, WIP)]]
  - [[#toggle-lsp-mode-vs-eglot][toggle: lsp-mode vs eglot]]
  - [[#sane-defs-1][sane defs]]
  - [[#parenthesis-matching][parenthesis matching]]
  - [[#tooling][tooling]]
    - [[#direnv][direnv]]
    - [[#hex-colors][hex colors]]
    - [[#colorize-ansi-escape-sequences][colorize ANSI escape sequences]]
  - [[#project-management][project management]]
    - [[#projectile][projectile]]
    - [[#project][project]]
  - [[#syntax-checkers][syntax checkers]]
    - [[#flycheck][Flycheck]]
    - [[#flymake][Flymake]]
  - [[#lsp-client][LSP client]]
    - [[#optimizations][optimizations]]
    - [[#lsp-mode][Lsp-mode]]
    - [[#eglot][Eglot]]
  - [[#langs][Langs]]
    - [[#lisp][Lisp]]
    - [[#nix][Nix]]
    - [[#lua][Lua]]
    - [[#rust][Rust]]
    - [[#java][Java]]
    - [[#c][C]]
    - [[#haskell][Haskell]]
    - [[#scala-disabled][Scala (disabled)]]
    - [[#yaml][YAML]]
    - [[#html][HTML]]
    - [[#markdown][Markdown]]
    - [[#typst][Typst]]
    - [[#kerolox-disabled][Kerolox (disabled)]]
  - [[#meta][Meta]]
    - [[#tree-sitter-setup][Tree-sitter setup]]
    - [[#outline][Outline]]
    - [[#outline-faces][Outline faces]]
- [[#org][Org]]
  - [[#leader-o][leader-o]]
  - [[#basics][basics]]
  - [[#fonts][fonts]]
  - [[#colorize-next-face][colorize NEXT face]]
  - [[#exclude---matching-like-parens][exclude "<" ">" matching like parens]]
  - [[#syntax-highlighting-on-org-latex-exports][syntax highlighting on org-latex exports]]
  - [[#org-toc][org-toc]]
  - [[#anki-editor][anki-editor]]
    - [[#scripts][scripts]]
  - [[#org-tempo-disabled][org-tempo (Disabled)]]
  - [[#auto-tangle][auto-tangle]]
  - [[#image-slicing][image-slicing]]
  - [[#agenda-todo-tweak-optimize-workflow][Agenda (TODO: tweak, optimize workflow)]]
  - [[#org-habit][org-habit]]
  - [[#org-super-agenda][org-super-agenda]]
  - [[#org-ql-disabled][org-ql (disabled)]]
  - [[#misc-functions-for-org-agenda][misc functions for org-agenda]]
  - [[#org-noter][org-noter]]
  - [[#org-capture-todo][org-capture (TODO)]]
  - [[#org-download][org-download]]
  - [[#visual-fill-column][visual fill column]]
  - [[#org-bullets][org-bullets]]
  - [[#org-modern-disabled][org-modern (disabled)]]
  - [[#pomodoro][pomodoro]]
- [[#latex][Latex]]
- [[#workspaces][Workspaces]]
- [[#programs][Programs]]
- [[#ui-1][UI]]
  - [[#leader-t][leader-T]]
  - [[#load-theme-hook][load-theme-hook]]
- [[#misc-1][Misc]]
- [[#to-sort][To-sort]]

* TODO to add

- command to check if init.el is valid (linter? run in new emacs for errors?)
- create an org-src-elisp-mode-hook to hook paredit, raindow-paren, and etc.

* early-init.el
  
#+begin_src elisp :tangle early-init.el

(eval-when-compile
  (require 'cl-lib))

;; settings

(setq gc-cons-threshold (* 50 1000 1000)) ; gc freq
(setq package-enable-at-startup nil)      ; dont load package.el

;; dir vars

(defvar my/emacs-root-dir user-emacs-directory)

(cl-macrolet
    ((defdir (name sub)
       `(defvar ,name
          (file-name-as-directory
           (expand-file-name ,sub my/emacs-root-dir)))))
  (defdir my/emacs-init-dir "init")
  (defdir my/emacs-src-dir "src")
  (defdir my/emacs-local-dir "local")
  (defdir my/emacs-submodules-dir "submodules"))

(defvar my/emacs-config-file
  (expand-file-name "Config.org" my/emacs-root-dir))

(setq user-emacs-directory my/emacs-local-dir) ; main dir

(setq custom-file ;; set custom-file location
      (expand-file-name "custom-vars.el" my/emacs-local-dir))

;; change eln-cache dir

(when (and (fboundp 'startup-redirect-eln-cache)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
  (startup-redirect-eln-cache
   (convert-standard-filename
    (expand-file-name  "var/eln-cache/" my/emacs-local-dir))))

;; ui

(advice-add 'tool-bar-setup :override #'ignore) ; disable tool bar

(setq tool-bar-mode nil                 ; disable tool bar
      menu-bar-mode nil                 ; disable menu bar
      scroll-bar-mode nil)              ; disable vertical scroll bar

(setq default-frame-alist
      '((tool-bar-lines . 0)            ; disable tool bar
        (menu-bar-lines . 0)            ; disable menu bar
        (vertical-scroll-bars)          ; disable vertical scroll bar
        (drag-internal-border . t)
        ;; (internal-border-width . 13) ; box border around buffer+modeline (creates gap)
        (fullscreen . maximized)        ; TODO: ???
        (left-fringe)                   ; set left fringe
        (right-fringe)                  ; set right fringe
        ))

;; transparency

(let ((value 95))
  (unless (assoc 'alpha-background default-frame-alist)
    (add-to-list 'default-frame-alist
                 `(alpha-background . ,value))))

;; misc tweaks

(setenv "LSP_USE_PLISTS" "true")        ; lsp-mode
(setq lsp-use-plists t)                 ; lsp-mode

#+end_src

* init.el

#+begin_src elisp :tangle init.el

(load (expand-file-name "config.el" my/emacs-root-dir))

#+end_src

* Sane Defs

#+begin_src elisp

;; sane defs

(setq load-prefer-newer t)              ; run .el instead of .elc if newer
(setq native-comp-async-report-warnings-errors nil) ; less warnings

#+end_src

* Package Manager

#+begin_src elisp

;; package manager

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

* setup.el
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src elisp

;; setup.el

(straight-use-package 'setup)
(require 'setup)

(advice-add 'setup :around
            (defun my/setup-advice (orig-fn recipe &rest body)
              (if (memq :disabled body)
                  (format "%S :disabled by setup" recipe)
                (apply orig-fn recipe body))))

#+end_src

** setc

#+begin_src elisp

(defmacro setc (&rest args)
  "Customize user options using ARGS like `setq'."
  (declare (debug setq))
  `(setup (:option ,@args)))

#+end_src

** :global

#+begin_src elisp

(setup-define :global
  (lambda (key command)
    `(global-set-key ,key ,command))
  :documentation "Globally bind KEY to COMMAND."
  :debug '(form sexp)
  :ensure '(kbd func)
  :repeatable t)

#+end_src

** :autoload

#+begin_src elisp

(setup-define :autoload
  (lambda (func)
    (let ((fn (if (memq (car-safe func) '(quote function))
                  (cadr func)
                func)))
      `(unless (fboundp (quote ,fn))
         (autoload (function ,fn) ,(symbol-name (setup-get 'feature)) nil t))))
  :documentation "Autoload COMMAND if not already bound."
  :repeatable t
  :signature '(FUNC ...))

#+end_src

** :quit

#+begin_src elisp

(setup-define :quit
  #'setup-quit
  :documentation "Unconditionally abort the evaluation of the current body.")

#+end_src

** :with-local-quit

#+begin_src elisp

(setup-define :with-local-quit
  (lambda (&rest body)
    `(catch ',(setup-get 'quit)
       ,@body))
  :documentation "Prevent any reason to abort from leaving beyond BODY."
  :debug '(setup))

#+end_src

** :load-after

#+begin_src elisp

(setup-define :load-after
  (lambda (&rest features)
    (let ((body `(require ',(setup-get 'feature))))
      (dolist (feature (nreverse features))
        (setq body `(with-eval-after-load ',feature ,body)))
      body))
  :documentation "Load the current feature after FEATURES.")

#+end_src

** :unhook

#+begin_src elisp

(setup-define :unhook
  (lambda (func)
    `(remove-hook (quote ,(setup-get 'hook)) ,func))
  :documentation "Remove FUNC from the current hook."
  :repeatable t
  :ensure '(func)
  :signature '(FUNC ...))

#+end_src

** :local-unhook

#+begin_src elisp

(setup-define :local-unhook
  (lambda (hook &rest functions)
    `(add-hook
      (quote ,(setup-get 'hook))
      (lambda ()
        ,@(mapcar
           (lambda (arg)
             (let ((fn (cond ((eq (car-safe arg) 'function) arg)
                             ((eq (car-safe arg) 'quote)    `(function ,(cadr arg)))
                             ((symbolp arg)                 `(function ,arg))
                             (t                             arg))))
               `(remove-hook (quote ,hook) ,fn t)))
           functions))))
  :documentation "Remove FUNCTION from HOOK only in the current hook."
  :debug '(&rest sexp)
  :repeatable nil)

#+end_src

** :advice

#+begin_src elisp

(setup-define :advice
  (lambda (symbol where function)
    `(advice-add ',symbol ,where ,function))
  :documentation "Add a piece of advice on a function.
See `advice-add' for more details."
  :after-loaded t
  :debug '(sexp sexp function-form)
  :ensure '(nil nil func)
  :repeatable t)

#+end_src

** :advice-def

#+begin_src elisp

(setup-define :advice-def
  (lambda (symbol where arglist &rest body)
    (let ((name (gensym "setup-advice-")))
      `(progn
         (defun ,name ,arglist ,@body)
         (advice-add ',symbol ,where #',name))))
  :documentation "Add a piece of advice on a function.
See `advice-add' for more details."
  :after-loaded t
  :debug '(sexp sexp function-form)
  :indent 3)

#+end_src

** :load-from

#+begin_src elisp

(setup-define :load-from
  (lambda (path)
    `(let ((path* (expand-file-name ,path)))
       (if (file-exists-p path*)
           (add-to-list 'load-path path*)
         ,(setup-quit))))
  :documentation "Add PATH to load path.
This macro can be used as NAME, and it will replace itself with
the nondirectory part of PATH.
If PATH does not exist, abort the evaluation."
  :shorthand (lambda (args)
               (intern
                (file-name-nondirectory
                 (directory-file-name (cadr args))))))

#+end_src

** :diminish

#+begin_src elisp

(setup-define :diminish
  (lambda (&optional mode &rest rest)
    (let* ((mode (or mode (setup-get 'mode)))
           (mode (if (string-match-p "-mode\\'" (symbol-name mode))
                     mode
                   (intern (format "%s-mode" mode)))))
      `(diminish ',mode ,rest)))
  :documentation "Hide the mode-line lighter of the current mode.
Alternatively, MODE can be specified manually, and override the
current mode."
  :after-loaded t)

#+end_src

** :option* (shorthand)

#+begin_src elisp

(setup-define :option*
  (lambda (name val)
    `(customize-set-variable
      ',(intern (format "%s-%s" (setup-get 'feature) name))
      ,val
      ,(format "Set for %s's setup block" (setup-get 'feature))))
  :documentation "Set the option NAME to VAL.
NAME is not the name of the option itself, but of the option with
the feature prefix."
  :debug '(sexp form)
  :repeatable t)

#+end_src

** :doc

#+begin_src elisp

(defvar setup--doc-alist nil "AList of docs for setup blocks.")

(setup-define :doc
  (lambda (string)
    `(add-to-list 'setup--doc-alist '(,(setup-get 'feature) . ,string)))
  :documentation "Allow documentation using STRING.
This will be ignored at expansion."
  :signature '(STRING ...)
  :repeatable nil)

#+end_src

** :pkg

#+begin_src elisp

(setup-define :pkg
  (lambda (recipe)
    `(unless (straight-use-package ',recipe)
       ,(setup-quit)))
  :documentation
  "Install RECIPE with `straight-use-package'.
This macro can be used as HEAD, and will replace itself with the
first RECIPE's package."
  :repeatable t
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe)
                     (car recipe)
                   recipe))))

(defmacro -setup (recipe &rest body)
  (declare (indent 1))
  (if (memq :disabled body)
      (format "%S :disabled by -setup" recipe)
    `(setup (:pkg ,recipe)
       ,@body)))

#+end_src

** catch errors, throw warnings

#+begin_src elisp

;; method 1
;; (setq setup-modifier-list '(setup-wrap-to-demote-errors))

;; method 2
(progn
  (defun my-protect-setup (expansion)
    "Wrap `setup' output with `condition-case'."
    (let ((err (gensym "setup-err")))
      `(condition-case ,err
           ,expansion
         (error
          (display-warning 'setup (concat "Problem in config: "
                                          (error-message-string ,err)
                                          ": \n"
                                          (with-output-to-string
                                            (pp (quote ,expansion))))
                           :error)))))
  (advice-add 'setup :filter-return #'my-protect-setup))

#+end_src

** benchmark all

#+begin_src elisp

(defun my/benchmark-log (fmt &rest args)
  "Log a message into the *My Log* buffer."
  (with-current-buffer (get-buffer-create "*Benchmark Log*")
    (goto-char (point-max))
    (insert (apply #'format fmt args) "\n")))

(defmacro my/benchmark-progn (name &rest body)
  (declare (debug t) (indent defun))
  (let ((value (make-symbol "value"))
        (start (make-symbol "start"))
        (gcs (make-symbol "gcs"))
        (gc (make-symbol "gc")))
    `(let ((,gc gc-elapsed)
           (,gcs gcs-done)
           (,start (current-time))
           (,value (progn
                     ,@body)))
       (my/benchmark-log "Benchmark [%fs%s] : %s"
                         (float-time (time-since ,start))
                         (if (> (- gcs-done ,gcs) 0)
                             (format " (%fs in %d GCs)"
                                     (- gc-elapsed ,gc)
                                     (- gcs-done ,gcs))
                           "")
                         ,name)
       ,value)))

(defun my/setup-benchmark-wrap (orig-fun &rest args)
  (my/benchmark-progn (nth 0 args)
                      (apply orig-fun args)))

(advice-add 'setup :around #'my/setup-benchmark-wrap)

#+end_src

** :require-self

#+begin_src elisp

(setq setup-macros (assq-delete-all ':require setup-macros))

(setup-define :require-self
  (lambda (&optional feature)
    (let ((pkg-feature (or feature
                           (setup-get 'feature)
                           (error "No feature specified and no context available"))))
      `(unless (require ',pkg-feature nil t)
         ,(setup-quit))))
  :documentation "Try to require FEATURE, or stop evaluating body.
If FEATURE is The first FEATURE can be used to deduce the feature context.")

#+end_src

** :hook-into-all

#+begin_src elisp

(setup-define :hook-into-all
  (lambda (mode-lst)
    `(dolist (hook ,mode-lst)
       (add-hook hook #',(setup-get 'func))))
  :documentation "For each mode hook in MODE-LST, add current function."
  :repeatable nil)

#+end_src

* Necessary Packages

** No Littering

#+begin_src elisp

(-setup no-littering
  (:option auto-save-default nil        ; don't autosave all file buffers
           backup-by-copying t)         ; safer backups

  ;; Dont litter project folders with backup files
  (let ((backup-dir (no-littering-expand-var-file-name "backup/")))
    (make-directory backup-dir t)
    (:option backup-directory-alist
             `(("\\`/tmp/" . nil)
               ("\\`/dev/shm/" . nil)
               ("." . ,backup-dir))))

  ;; Tidy up auto-save files
  (let ((auto-save-dir (no-littering-expand-var-file-name "auto-save/")))
    (make-directory auto-save-dir t)
    (:option auto-save-file-name-transforms
             `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'"
                ,(concat (file-name-as-directory temporary-file-directory) "\\2") t)
               ("\\`/tmp\\([^/]*/\\)*\\(.*\\)\\'" "\\2")
               ("\\`/dev/shm\\([^/]*/\\)*\\(.*\\)\\'" "\\2")
               ("." ,auto-save-dir t)))))

#+end_src

** Exec-path-from-shell

Fix issues with missing programs from shell.

#+begin_src elisp

(-setup exec-path-from-shell
  (when (or (memq window-system '(pgkt x))
            (daemonp))
    (exec-path-from-shell-initialize)))

#+end_src

** General

Quickly set up keybinds.

#+begin_src elisp

(-setup general
  (general-create-definer leader-bind :prefix "C-c"))

#+end_src

** Diminish

Hide modes from the modeline.

#+begin_src elisp

(-setup diminish
  (:require-self))

#+end_src

** Which-key

Display keystroke options.

#+begin_src elisp

(-setup which-key
  (:diminish)
  (:option* idle-delay 0.3)
  (which-key-mode 1))

#+end_src

** Hydra

Lingering key menus for repeated key-presses.

#+begin_src elisp

(-setup hydra
  (defmacro my/defhydra-repeat (fn keys)
    "Create a repeatable function FN from a list of KEYS."
    (let* ((fn-hydra (intern (concat (symbol-name fn) "-hydra"))))
      `(defhydra ,fn-hydra ()
         ,@(mapcar (lambda (k)
                     (list k fn))
                   keys)))))

#+end_src

** Dash

#+begin_src elisp

(-setup dash
  (:require-self)
  
  ;; FIXME
  (defun -debug (label)
    "Debugging helper function for dash.el."
    (lambda (m)
      (message "%s: %S" label m)
      m))

  ;; FIXME
  (defmacro -tap (value form)
    "Evaluate FORM with VALUE as its argument, then return VALUE unchanged.
This is the non-anaphoric version - VALUE is passed as an argument to FORM."
    `(let ((val ,value))
       ,form
       val))

  ;; FIXME
  (defmacro --tap (value &rest body)
    "Evaluate BODY with VALUE bound to `it`, then return VALUE unchanged.
  This is the anaphoric version - VALUE is available as `it` in BODY."
    `(let ((it ,value))
       ,@body
       it))

  ;; FIXME
  (defmacro --tap (value &rest body)
    "Evaluate BODY with VALUE bound to `it`, then return VALUE unchanged.
  This is the anaphoric version - VALUE is available as `it` in BODY."
    (declare (debug (form body)) (indent 1))
    (let ((val (make-symbol "value")))
      `(let ((,val ,value))
         (let ((it ,val))
           (ignore it)
           ,@body)
         ,val))))

#+end_src

** f

File/Directory API library.
https://github.com/rejeep/f.el

#+begin_src elisp

(-setup f)

#+end_src

** s

String manipulation library.
https://github.com/magnars/s.el

#+begin_src elisp

(-setup s)

#+end_src

** Consult

Search and navigation commands.

#+begin_src elisp

(-setup consult
  (:global "C-c M-x" consult-mode-command
           ;; Search
           "C-s" consult-line
           "C-S-s" consult-line-multi
           ;; Recentf
           [remap recentf] #'consult-recent-file
           ;; Buffers
           [remap switch-to-buffer] #'consult-buffer
           [remap switch-to-buffer-other-window] #'consult-buffer-other-window
           [remap switch-to-buffer-other-frame] #'consult-buffer-other-frame
           ;; Editing
           "M-y" consult-yank-pop
           "M-S-y" consult-yank-from-kill-ring
           "<f5>" consult-kmacro
           ;; Registers (C-u for window layout!)
           "M-#" consult-register-store  ; store
           "C-M-#" consult-register-load ; load
           ;; Themes
           [remap load-theme] #'consult-theme
           ;; Info
           [remap Info-search] consult-info)

  ;; --- Type: Buffers ---

  ;; exclude some sources
  (:when-loaded
    (:option consult-buffer-sources
             (->> consult-buffer-sources
                  (delete 'consult--source-bookmark)
                  ;; (delete 'consult--source-recent-file)
                  ;; (delete 'consult--source-project-recent-file-hidden)
                  )))

  ;; --- Type: Info ---

  ;; info search groups
  (:when-loaded
    (consult-info-define 'elisp "emacs" "elisp" "dash" "cl")
    (consult-info-define 'org "org" "org-ql" "org-super-agenda")
    (consult-info-define "magit"))

  ;; --- Type: Registers ---

  ;; improve register preview
  (:when-loaded
    (advice-add #'register-preview :override #'consult-register-window)
    (setc register-preview-delay 0.5))

  ;; --- Narrowing ---

  (:option consult-narrow-key "<"                ; narrowing separator
           consult-async-split-style 'semicolon) ; 2-lvl filter separator

  ;; --- Integration ---

  ;; isearch integration
  (:with-map isearch-mode-map
    (:bind "M-r" consult-isearch-history))

  ;; lsp-mode
  (:with-feature lsp-mode
    (:with-map lsp-mode-map
      (:bind "C-c l e" consult-compile-error)))

  ;; minibuffer history
  (:with-map minibuffer-local-map
    (:bind "M-r" consult-history))

  ;; xref integration
  (:option xref-show-xrefs-function #'consult-xref
           xref-show-definitions-function #'consult-xref)

  ;; prolly not needed:
  ;; projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))

  ;; --- Preview: Allowed modes ---

  (:when-loaded
    (add-to-list 'consult-preview-allowed-hooks 'hl-todo-mode)
    (add-to-list 'consult-preview-allowed-hooks 'global-hl-todo-mode)
    (add-to-list 'consult-preview-allowed-hooks 'elide-head-mode)
    (add-to-list 'consult-preview-allowed-hooks 'global-org-modern-mode))

  ;; --- Preview: Delay ---

  (:when-loaded
    ;; default
    (:option consult-preview-key
             '(:debounce 0.05 any))

    ;; custom
    (consult-customize consult-man
                       consult-bookmark
                       consult-xref
                       :preview-key '(:debounce 0.1 any))
    (consult-customize consult-recent-file
                       consult--source-recent-file
                       consult--source-project-recent-file
                       :preview-key '(:debounce 0.3 any))
    (consult-customize consult-ripgrep
                       consult-git-grep
                       consult-grep
                       :preview-key '(:debounce 0.5 any))))

#+end_src

*** Consult-dir

Entrypoints for find-file.

Binds in [[leader-f]] heading.

#+begin_src elisp

(-setup consult-dir)

#+end_src

*** leader-s

- TODO: move all these leader binds to the very bottom of the config?

#+begin_src elisp

(defun my/consult-heading ()
  "Dwim between `consult-outline' or `consult-org-heading'."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (call-interactively #'consult-org-heading)
    (call-interactively #'consult-outline)))

(leader-bind
  "s" '(:ignore t :wk "Search")
  ;; navigation
  "sh" '(my/consult-heading  :wk "heading")
  "si" '(consult-imenu       :wk "imenu")         ; list var/func
  "sI" '(consult-imenu-multi :wk "imenu-project") ; all buffers in project
  ;; search
  "sk" '(consult-keep-lines  :wk "delete-nonmatching")
  "sl" '(consult-focus-lines :wk "focus-lines") ; reset: C-u, invert: !
  ;; grep (in files)
  "sr" '(consult-ripgrep     :wk "ripgrep")
  ;; find (filename)
  "sf" '(consult-fd          :wk "fd")
  "sF" '(consult-locate      :wk "locate")
  ;; histories
  "sx" '(consult-complex-command :wk "past-keychords")
  ;; info
  "sI" '(consult-info :wk "Info")
  ;; man
  "sm" '(tldr :wk "tldr")
  "sM" '(consult-man :wk "man")
  ;; MISC
  "s" '(:ignore t :wk "MISC")
  ;; list minor modes
  "ssm" '(consult-minor-mode-menu :wk "all-minor-modes"))

#+end_src

* startup hooks

#+begin_src elisp

;; print init time
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s seconds with %d garbage collections."
                     (emacs-init-time "%.2f")
                     gcs-done)))

;; increase gc freq
(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-threshold (* 10000 10000))))

;; load saved customizations file
;; TODO: load this sooner? prevent freezing due to dir-locals by org-agenda
(add-hook 'after-init-hook
          (lambda ()
            (when (file-exists-p custom-file)
              (load custom-file))))

#+end_src

* TODO log

#+begin_src elisp

(defun my/benchmark-lambdas (f1 f2 &optional n)
  (let* ((n (or n 10000))
         (time1 (car (benchmark-run n (funcall f1))))
         (time2 (car (benchmark-run n (funcall f2))))
         (less (if (< time1 time2) "f1" "f2"))
         (symbol (if (< time1 time2) "<" ">"))
         (difference (if (> time1 time2)
                         (- time1 time2)
                       (- time2 time1))))
    (message "f1: %.6f %s f2: %.6f (%s faster by %.6f)"
             time1
             symbol
             time2
             less
             difference)))

#+end_src

* Buffers

** autorevert

#+begin_src elisp

(setup autorevert
  (:option auto-revert-verbose nil      ; don't print "Reverting buffer"
           auto-revert-interval 5       ; manual check interval
           global-auto-revert-non-file-buffers t) ; work on non-file buffers
  (global-auto-revert-mode 1))

#+end_src

** auto-sudoedit

Auto re-open files with sudoedit when needed.

#+begin_src elisp

(-setup auto-sudoedit
  (:autoload auto-sudoedit-sudoedit))

#+end_src

** buttonize urls

#+begin_src elisp

(add-hook 'after-init-hook #'global-goto-address-mode)

#+end_src

** leader-b

#+begin_src elisp

(setup emacs
  (defalias 'my/last-selected-buffer #'mode-line-other-buffer)
  (leader-bind
    "b" '(:ignore t :wk "Buffer")
    "bb" '(consult-buffer          :wk "switch-to")
    "bk" '(kill-current-buffer     :wk "kill-current")
    "bn" '(next-buffer             :wk "next")
    "bp" '(previous-buffer         :wk "prev")
    "bo" '(my/last-selected-buffer :wk "last")
    "bs" '(save-buffer             :wk "save")))

#+end_src

** leader-k

#+begin_src elisp

(setup emacs
  (leader-bind
    "k" '(kill-current-buffer :wk "kill-current")))

#+end_src

* History

- recentf :: track recently opened files, search with ~recentf~.
- saveplace :: save cursor location in file when saving.
- savehist :: persist minibuffer history over restarts.

#+begin_src elisp

;; history

(setup emacs
  ;; recentf
  (add-hook 'emacs-startup-hook #'recentf-mode)

  ;; saveplace
  (save-place-mode 1)

  ;; savehist
  (savehist-mode 1))

#+end_src

* Windows

** Ace-window

Efficiently switch between Emacs windows.
https://github.com/abo-abo/ace-window

#+begin_src elisp


(-setup ace-window
  (:option aw-scope 'frame                     ; selectable scope
           aw-keys '(?a ?o ?e ?u ?h ?t ?n ?s)) ; possible keys

  ;; entrypoint
  (:global "M-o" #'ace-window))

#+end_src

** hydra-window

#+begin_src elisp

(defhydra hydra-window ()
  "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_v_ertical    	_b_uffer		_q_ X←
_j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
_l_ →        	_Z_ reset      	_s_wap		_r_ X→
_F_ollow		_D_lt Other   	_S_ave		max_i_mize
_SPC_ cancel	_o_nly this   	_d_elete
"
  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("q" hydra-move-splitter-left)
  ("w" hydra-move-splitter-down)
  ("e" hydra-move-splitter-up)
  ("r" hydra-move-splitter-right)
  ("b" helm-mini)
  ("f" helm-find-files)
  ("F" follow-mode)
  ("a" (lambda ()
         (interactive)
         (ace-window 1)
         (add-hook 'ace-window-end-once-hook
                   'hydra-window/body)))
  ("v" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right)))
  ("x" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)))
  ("s" (lambda ()
         (interactive)
         (ace-window 4)
         (add-hook 'ace-window-end-once-hook
                   'hydra-window/body)))
  ("S" save-buffer)
  ("d" delete-window)
  ("D" (lambda ()
         (interactive)
         (ace-window 16)
         (add-hook 'ace-window-end-once-hook
                   'hydra-window/body)))
  ("o" delete-other-windows)
  ("i" ace-maximize-window)
  ("z" (progn
         (winner-undo)
         (setq this-command 'winner-undo)))
  ("Z" winner-redo)
  ("SPC" nil))

#+end_src

** leader-w

#+begin_src elisp

(leader-bind
  "w" '(:ignore t :wk "window")
  "wh" '(hydra-window/body         :wk "Hydra")
  "wd" '(delete-window             :wk "delete")
  "w=" '(balance-windows           :wk "balance-ratio")
  "wa" '(balance-windows-area      :wk "balance-size")
  "wv" '(split-window-horizontally :wk "split-h")
  "ws" '(split-window-vertically   :wk "split-v")
  "wp" '(windmove-up               :wk "select-up")
  "wn" '(windmove-down             :wk "select-down")
  "wf" '(windmove-right            :wk "select-right")
  "wb" '(windmove-left             :wk "select-left")
  "wm" '(switch-to-minibuffer      :wk "select-minibuffer"))

#+end_src

* Files

** Dired

- dired :: The Emacs file-manager.
- dired-launch :: open files in external applications.

#+begin_src elisp

;; dired

(setup dired
  ;; settings
  (:option dired-dwim-target t           ; copy file to other dired window cwd
           dired-auto-revert-buffer t    ; auto update file changes
           dired-switches-in-mode-line 0 ; hide switches in modeline
           dired-listing-switches "-Ahl --group-directories-first -X")

  ;; dired-mode-map
  (:bind "h" #'dired-up-directory
         "s" #'dired-find-file
         "r" #'dired-sort-toggle-or-edit)

  ;; hide details by default
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  
  ;; use trash if trash executable is found
  (:when-loaded
    (when (executable-find "trash")
      (setc delete-by-moving-to-trash t))))

;; dired-launch

(-setup dired-launch
  (:load-after dired)
  (:diminish)
  (:option dired-launch-extensions-map
           '(("pptx" ("libreoffice"))
             ("docx" ("libreoffice"))
             ("odt"  ("libreoffice"))
             ("html" ("librewolf"))))
  (:when-loaded
    (dired-launch-enable)))

#+end_src

** leader-f/d

#+begin_src elisp

(setup emacs

  ;; (defvar my/emacs-config-file
  ;;   (directory-file-name
  ;;    (expand-file-name "Config.org" my/emacs-root-dir)))

  (defun my/open-emacs-config ()
    "Open emacs config file."
    (interactive)
    (find-file my/emacs-config-file))

  (defun my/open-agenda-file ()
    "Open agenda file."
    (interactive)
    (when-let* ((f (car org-agenda-files)))
      (find-file f)))

  (leader-bind
    "f" '(:ignore t :wk "Files")
    "ff" '(find-file            :wk "find-file")
    "fd" '(consult-dir          :wk "entrypoints")
    "fr" '(consult-recent-file  :wk "recentf")
    "fj" '(dired-jump           :wk "cwd")
    "fp" '(my/open-emacs-config :wk "emacs-config")
    "fa" '(my/open-agenda-file  :wk "agenda-file"))

  ;; alias
  (leader-bind
    "d" '(:ignore t :wk "Files")
    "df" '(find-file            :wk "find-file")
    "dd" '(consult-dir          :wk "entrypoints")
    "dr" '(consult-recent-file  :wk "recentf")
    "dj" '(dired-jump           :wk "cwd")
    "dp" '(my/open-emacs-config :wk "emacs-config")
    "da" '(my/open-agenda-file  :wk "agenda-file"))
  )

#+end_src

* Misc

** Helpful

Improve the Emacs help buffer with more info.
https://github.com/Wilfred/helpful

#+begin_src elisp

(-setup helpful
  ;; TODO: is this needed?
  ;; (:autoload helpful--bookmark-jump)
  ;; (:option
  ;;  (counsel-describe-function-function . #'helpful-callable)
  ;;  (counsel-describe-variable-function . #'helpful-variable))
  (:global [remap describe-function] #'helpful-callable
           [remap describe-symbol]   #'helpful-symbol
           [remap describe-variable] #'helpful-variable
           [remap describe-command]  #'helpful-command
           [remap describe-key]      #'helpful-key
           "C-h h" #'helpful-at-point
           "C-h M" #'describe-keymap
           "C-h s" #'which-key-show-major-mode
           "C-h S" #'which-key-show-minor-mode-keymap)

  ;; enable scrolling with 'n' and 'p'
  (:bind "n" #'next-line
         "p" #'previous-line))

#+end_src

** tldr

- Bound in [[leader-s]].

#+begin_src elisp

(-setup tldr)

#+end_src

** leader-D (profiling)

#+begin_src elisp

(setup emacs
  (defun my/profiler-report ()
    "Profiler stop and report."
    (interactive)
    (profiler-stop)
    (profiler-report))

  (leader-bind
    "D" '(:ignore t :wk "Debug")
    "Ds" 'profiler-start
    "Dr" 'my/profiler-report))

#+end_src

** user

#+begin_src elisp

(setc user-full-name "lispcat"
      user-mail-address "187922791+lispcat@users.noreply.github.com")

#+end_src

* Keyboard

** quality of life

#+begin_src elisp

(setup emacs
  ;; Actuates Meta key by default
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Shorten yes/no prompts to y/n
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; By default, Emacs thinks two spaces after a period is a sentence.
  ;; This changes that to just one space.
  (setq sentence-end-double-space nil)

  ;; nice keybinds for navigation
  (global-set-key (kbd "M-p") (kbd "M-- 1 C-v"))
  (global-set-key (kbd "M-n") (kbd "M-- 1 M-v"))

  (defun my/scroll-down-half-page ()
    (interactive)
    (scroll-up-command (/ (window-body-height) 2)))

  (defun my/scroll-up-half-page ()
    (interactive)
    (scroll-down-command (/ (window-body-height) 2))))

#+end_src

** Meow

#+begin_src elisp

(defun my/meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-dvp)
  (meow-motion-overwrite-define-key
   ;; custom keybinding for motion state
   '("<escape>" . ignore)
   '("t" . "p") ;; improved solution? (access Motion "t" with "SPC t")
   )
  (meow-leader-define-key
   '("u" . meow-universal-argument)
   '("t" . "H-t")
   ;; '("p" . "H-p")
   ;; '("u" . ctl-x-map)
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   ;; make S-<num> easier to hit with DVP by using symbols.
   '("*" . meow-expand-0)
   '("=" . meow-expand-9)
   '("!" . meow-expand-8)
   '("[" . meow-expand-7)
   '("]" . meow-expand-6)
   '("{" . meow-expand-5)
   '("+" . meow-expand-4)
   '("}" . meow-expand-3)
   '(")" . meow-expand-2)
   '("(" . meow-expand-1)
   '("1" . digit-argument)
   '("2" . digit-argument)
   '("3" . digit-argument)
   '("4" . digit-argument)
   '("5" . digit-argument)
   '("6" . digit-argument)
   '("7" . digit-argument)
   '("8" . digit-argument)
   '("9" . digit-argument)
   '("0" . digit-argument)
   ;; symbols
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '(":" . consult-goto-line) ;; moved from "Q" and "E"
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("<" . meow-beginning-of-thing)
   '(">" . meow-end-of-thing)
   ;; basic letters
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   ;; '("d" . ri/meow-delete-or-kill)
   '("d" . meow-delete) ; i want "d" to delete char after meow-prev/next-word, so dont use former
   '("D" . meow-backward-delete)
   '("e" . meow-line)
   ;; '("E" . meow-goto-line) ;; removed, since ":" for it works
   '("f" . meow-find)
   '("F" . meow-search) ;; moved from "s" ("s" is used for movement)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   ;; H Directional key moved to the bottom
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-join)
   '("k" . meow-kill)
   '("l" . meow-till)
   ;; '("m" . meow-mark-word) ;; swap with w, next-word (because "b"/"m" is easy for mvmnt)
   ;; '("M" . meow-mark-symbol) ;; swap with W, next-symbol (because "b"/"m" is easy for mvmnt)
   '("m" . meow-next-word)   ;; moved from "w", mark-word
   '("M" . meow-next-symbol) ;; moved from "W", mark-symbol
   ;; N Directional key moved to the bottom
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-prev)
   '("P" . meow-prev-expand)
   '("q" . meow-quit)
   '("Q" . ri/quit-temp-window)
   ;; '("Q" . meow-goto-line) ;; move to " : "
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   ;; '("s" . meow-search) ;; move to F, replace with directional keys
   ;; S Directional key moved to the bottom
   ;; T Directional key moved to the bottom
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   ;; '("w" . meow-next-word) ;; swap with m, mark-word/symbol
   ;; '("W" . meow-next-symbol)
   '("w" . meow-mark-word)   ;; moved from "m", mark-word
   '("W" . meow-mark-symbol) ;; moved from "M", mark-symbol
   '("x" . meow-save)
   '("X" . meow-sync-grab)
   '("y" . meow-yank)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("/" . my/scroll-down-half-page) ;; new keys
   '("?" . my/scroll-up-half-page)   ;; new keys
   ;; '("<escape>" . ignore)

   '("@" . meow-universal-argument)

   ;; Directional keys:

   ;; <-  ^  v  ->
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("t" . meow-prev)
   '("T" . meow-prev-expand)
   '("n" . meow-next)
   '("N" . meow-next-expand)
   '("s" . meow-right)
   '("S" . meow-right-expand)

   ;; ^  <-  v  ->
   ;; '("h" . meow-prev)
   ;; '("H" . meow-prev-expand)
   ;; '("t" . meow-left)
   ;; '("T" . meow-left-expand)
   ;; '("n" . meow-next)
   ;; '("N" . meow-next-expand)
   ;; '("s" . meow-right)
   ;; '("S" . meow-right-expand)

   ;; ^  /  <-  ->  v
   ;; '("h" . meow-left)
   ;; '("H" . meow-left-expand)
   ;; '("t" . meow-right)
   ;; '("T" . meow-right-expand)
   ;; '("n" . meow-prev)
   ;; '("N" . meow-prev-expand)
   )
  (meow-global-mode 1))

(-setup meow
  (:require-self)
  (:option meow-use-cursor-position-hack t   ; insert before/after
           meow-keypad-leader-dispatch "C-c" ; keypad support local temp maps (?)
           meow-replace-state-name-list '((normal . "<N>") ; visuals
                                          (motion . "<M>")
                                          (keypad . "<K>")
                                          (insert . "<I>")
                                          (beacon . "<B>")))
  (my/meow-setup)

  ;; --- Auto insert mode ---

  (let ((modes '(vterm-mode
                 eshell-mode)))
    (dolist (m modes)
      (add-to-list 'meow-mode-state-list `(,m . insert))))

  ;; enter insert mode after creating new org heading
  (add-hook 'org-insert-heading-hook 'meow-insert)

  ;; --- Exiting insert mode ---

  (defun my/meow-exit-all-and-save ()
    "Exit insert mode, then save buffer."
    (interactive)
    ;; (execute-kbd-macro (kbd "<escape>"))
    (meow-insert-exit)
    (when (buffer-modified-p (current-buffer))
      (save-buffer)))

  (meow-define-keys 'insert
    '("C-g" . meow-insert-exit)
    '("C-M-g" . my/meow-exit-all-and-save))

  ;; --- TODO: Ignoring SPC ---

  (defvar my/meow-SPC-ignore-list
    '(Info-mode
      gnus-summary-mode
      gnus-article-mode
      w3m-mode)
    "Disable meow-keypad in these modes."))

#+end_src

** Avy

#+begin_src elisp

(-setup avy
  (leader-bind
    "j" 'avy-goto-char-timer
    "J" 'avy-goto-line)
  (:option avy-timeout-seconds 0.3
           avy-keys (mapcar #'string-to-char
                            (split-string "a o e u h t n s k b"))))

#+end_src

** Jinx - TODO: move

Spellchecking.

#+begin_src elisp

;; locally installed

(setup jinx
  (:require-self)
  (:hook-into org-mode-hook markdown-mode-hook text-mode-hook)
  (:global "M-$" jinx-correct
           "C-M-$" jinx-languages))

#+end_src

** Fontawesome - TODO: move

#+begin_src elisp

(-setup fontawesome
  ;; vertico variant
  (defun vertico-fontawesome ()
    (interactive)
    (require 'vertico)
    (insert
     (cdr
      (assoc
       (completing-read "Font awesome: " (fontawesome--construct-candidates))
       (fontawesome--construct-candidates)))))
  (:autoload vertico-fontawesome))

#+end_src

* Completion

- UI
  - vertico
  - candidate icons
  - marginalia
- 

** UI

*** Vertico

#+begin_src elisp

(-setup vertico
  (:option vertico-cycle t             ; cycle for `vertico-next/previous'
           vertico-count 10            ; Show more candidates (def 10)
           vertico-scroll-margin 3     ; Different scroll margin (def 2)
           vertico-resize 'grow-only)  ; Grow/shrink minibuffer (def 'grow-only)
  (:option
   ;; adds a menu in the minibuffer to switch display modes
   context-menu-mode t

   ;; Support opening new minibuffers from inside existing minibuffers.
   enable-recursive-minibuffers t

   ;; hide commands in M-x that do not work in the current mode.
   read-extended-command-predicate #'command-completion-default-include-p

   ;; do not allow the cursor in the minibuffer prompt
   minibuffer-prompt-properties '(read-only t cursor-intangible t
                                            face minibuffer-prompt))

  ;; enable
  (vertico-mode 1)

  (:global "C-M-c" #'completion-at-point)

  ;; prefix TAB completion
  (keymap-set vertico-map "<backtab>" #'minibuffer-complete)

  ;; Prompt indicator for `completing-read-multiple'.
  (when (< emacs-major-version 31)
    (advice-add #'completing-read-multiple :filter-args
                (lambda (args)
                  (cons (format "[CRM%s] %s"
                                (string-replace "[ \t]*" "" crm-separator)
                                (car args))
                        (cdr args)))))

  ;; --- Multiform mode ---

  ;; enable multiform
  (vertico-multiform-mode)

  ;; per command; form: ((cmd config..) ..)
  (setq vertico-multiform-commands
        `((consult-imenu buffer)
          (consult-outline buffer)))

  ;; per completion category
  (setq vertico-multiform-categories
        `((reverse (vertico-resize . 'grow-only)))))

#+end_src

*** Candidate icons

#+begin_src elisp

;; (-setup nerd-icons-corfu
;;   (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

(-setup kind-icon
  (:load-after corfu)
  (:when-loaded
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)

    ;; blend background
    (:option kind-icon-blend-background t
             kind-icon-default-face 'corfu-default)

    ;; update background after theme change
    (add-hook '+after-enable-theme-hook #'kind-icon-reset-cache)))

#+end_src

*** Marginalia

#+begin_src elisp

(-setup marginalia
  (marginalia-mode 1)
  (:with-map minibuffer-local-map
    (:bind "M-A" marginalia-cycle))
  (:with-map completion-list-mode-map
    (:bind "M-A" marginalia-cycle)))

#+end_src

** Orderless (completion style)

A better completion style.

#+begin_src elisp

(-setup orderless
  (:option completion-styles '(orderless basic)
           completion-category-defaults nil
           completion-category-overrides '((file (styles partial-completion)))

           ;; Make partial-completion work like substring
           completion-pcm-leading-wildcard t

           ;; Set style
           orderless-matching-styles '(orderless-prefixes orderless-regexp)
           ;; orderless-matching-styles '(orderless-flex orderless-regexp)

           ;; Dispatchers:
           ;; % : ignore diacritics
           ;; ! : not
           ;; & : annotation
           ;; , : initialim (first letter of every word)
           ;; = : literal
           ;; ^ : literal prefix
           ;; ~ : flex
           orderless-affix-dispatch-alist
           '((?% . char-fold-to-regexp)
             (?! . orderless-not)
             (?& . orderless-annotation)
             (?, . orderless-initialism)
             (?= . orderless-literal)
             (?^ . orderless-literal-prefix)
             (?~ . orderless-flex))))

#+end_src

** Embark (minibuffer actions)

Invoke relevant commands on the thing at point.
https://github.com/oantolin/embark

#+begin_src elisp

(-setup embark
  ;; DWIM binds (very useful)
  (:global "C-." my/embark-act-or-dwim ; univ-arg for dwim
           "C-," embark-dwim)

  ;; use completing-read ui for key help
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:
  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  ;; custom wrapper around embark-act to support dwim
  (defun my/embark-act-or-dwim (arg)
    (interactive "P")
    (if current-prefix-arg
        (embark-dwim)
      (embark-act)))

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

#+end_src

*** consult integration

consult-grep/ripgrep results -> results buffer.

- Note: The `embark-export' ("E") is extremely useful. Given a set of candidates, you can export them to a specialized buffer, unlocking more advanced and efficient editing workflows.

#+begin_src elisp

(-setup embark-consult
  (:load-after embark consult)
  (:when-loaded
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode)))

#+end_src

** in-buffer completion

*** Corfu

- TODO: [[https://github.com/minad/corfu/wiki#same-key-used-for-both-the-separator-and-the-insertion][same key for separator + insertion]]
- TODO: [[https://github.com/minad/corfu/wiki#tab-and-go-completion][tab-n-go completion]]

#+begin_src elisp

(-setup corfu
  (:require-self)
  (:option corfu-cycle t                ; cycle
           corfu-on-exact-match nil     ; on exact match, do nothing
           corfu-auto t                 ; auto popup
           ;; corfu-preselect 'prompt
           corfu-preselect 'first
           corfu-preview-current 'insert
           ;; corfu-preview-current 't
           corfu-auto-delay 0.15)

  (:with-map corfu-map
    (:bind
     "TAB" #'corfu-next
     [tab] #'corfu-next
     "S-TAB" #'corfu-previous
     [backtab] #'corfu-previous
     ;; "TAB" #'corfu-expand
     ;; [tab] #'corfu-expand
     ;; "TAB" #'corfu-insert
     ;; [tab] #'corfu-insert

     ;; temp
     ;; "TAB" #'corfu-complete
     ;; [tab] #'corfu-complete
     ;; "M-TAB" #'corfu-insert ; use for tempel next?
     ;; [M-tab] #'corfu-insert
     ;; "S-TAB" #'corfu-insert
     ;; [backtab] #'corfu-insert
     "S-<return>" #'corfu-insert

     ;; unbind C-n and C-p
     "C-n" nil
     "C-p" nil
     [remap previous-line] nil
     [remap next-line] nil

     ;; avy-style select
     "M-;" #'corfu-quick-complete

     ;; prevent M-TAB from opening another completion
     ;; "M-TAB" nil

     ;; ;; make S-RET insert
     ;; "S-RET" #'corfu-insert

     ;; make RET do nothing
     "RET" nil
     "C-<return>" nil

     ;; easier complete and expand appropriate
     ;; "C-<return>" #'corfu-complete
     ))

  ;; enable
  (global-corfu-mode)

  ;; optional modes
  (corfu-history-mode)                  ; sort by recent and freq
  (corfu-popupinfo-mode)                ; show docs to the right

  ;; avy-style completion
  (:with-map corfu-map
    (:bind "M-;" #'corfu-quick-complete))
  (:with-feature corfu-quick
    (:option corfu-quick1 "aoeuidhtns"
             corfu-quick2 "aoeuidhtns"))

  (:option
   ;; cycle only if few candidates
   ;; FIX: disabled since tempel wont show previews
   completion-cycle-threshold 10
   ;; completion-cycle-threshold nil

   ;; make TAB indent or complete
   tab-always-indent 'complete

   ;; disable ispell completion function (`cape-dict' better)
   text-mode-ispell-word-completion nil

   ;; decrease time for corfu popupinfo
   corfu-popupinfo-delay '(1.5 . 0.5)))

#+end_src

*** Company (Disabled)

An in-buffer completion framework.

Disabled in favor of [[corfu][corfu]].

#+begin_src elisp

(-setup company
  :disabled

  (:with-map company-active-map
    (:bind "<return>" nil
           "C-n" nil
           "C-p" nil
           "C-s" company-filter-candidates))
  (:option company-backends '(company-dabbrev company-files) ; the default, overrides below
           company-transformers nil
           lsp-completion-provider :none
           company-idle-delay 0.1
           company-selection-wrap-around t
           company-minimum-prefix-length 1
           company-dabbrev-downcase nil
           company-search-regexp-function
           'company-search-words-in-any-order-regexp)
  (:when-loaded
    (company-tng-configure-default)
    (global-company-mode 1)

    (defun +company-return-default-or-complete ()
      (interactive)
      ;; number if selected, nil if not
      (if company-selection
          (company-complete-selection)
        (company-abort)
        (execute-kbd-macro (kbd "<return>"))))
    (define-key company-tng-map (kbd "<return>") #'+company-return-default-or-complete)

    ;; -- org-mode-specific backends --

    (add-hook 'prog-mode-hook
              (lambda ()
                (setq-local company-backends
                            '((company-yasnippet :with company-capf)
                              company-dabbrev-code
                              company-files))
                (setq-local company-transformers '(company-sort-by-backend-importance))))
    (eval-after-load 'org
      '(add-hook 'org-mode-hook
                 (lambda ()
                   (setq-local company-backends
                               '((company-dabbrev :with company-files))))))
    (eval-after-load 'latex
      '(add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (setq-local company-backends'nil))))

    ;; - separator for orderless completion --

    (defvar +company-separator "&")
    (defun +company-insert-separator ()
      "Insert `+company-separator' during company completion."
      (interactive)
      (when (company-manual-begin)
        (insert +company-separator)))
    (define-key company-active-map (kbd "M-SPC") #'+company-insert-separator)
    (setq orderless-component-separator "[ &]")))

;; describe current selection
(-setup company-quickhelp
  (:load-after company)
  (:global "C-c l h c" company-quickhelp-mode)
  (:option company-quickhelp-delay 1)
  (:when-loaded
    (company-quickhelp-mode 1)))

#+end_src

** templates

*** Tempel

#+begin_src elisp

(-setup tempel-collection
  (:load-after tempel))

(-setup tempel
  (:global "M-*" #'tempel-insert)
  (:with-map tempel-map
    (:bind "M-<return>" #'tempel-next
           "C-o"        #'tempel-next)))

;; -- eglot integration --
;; (-setup eglot-tempel
;;   (eglot-tempel-mode t))

#+end_src

*** Yasnippet (Disabled)

TODO: [[https://stackoverflow.com/questions/72601990/how-to-show-suggestions-for-yasnippets-when-using-eglot][on yasnippet x eglot integration]]

#+begin_src elisp

(-setup yasnippet-snippets
  :disabled)

(-setup yasnippet
  :disabled

  (:require-self)
  (:diminish yas-minor-mode)

  (:with-map yas-keymap
    (:bind "RET" yas-next-field-or-maybe-expand))

  (:when-loaded
    ;; load snippets
    (:also-load yasnippet-snippets)
    ;; add custom snippets dir
    (add-to-list 'yas-snippet-dirs
                 (expand-file-name "no-search/snippets"
                                   my/emacs-src-dir))
    ;; reload all
    (with-eval-after-load 'yasnippet-snippets
      (yas-reload-all))))

;; -- yasnippet integration --

;; may cause freezing?
;; using cape, lsp + yasnippet capf

;; (-setup yasnippet-capf
;;   :disabled
;;   (:load-after yasnippet))

#+end_src

** Cape

Completion at Point Extensions
https://github.com/minad/cape

TODO: tweak, verify it works

#+begin_src elisp

(-setup cape
  (:require-self)
  (:also-load tempel tempel-collection)

  (:global "M-+" #'cape-prefix-map)

  ;; prevent lsp-mode from hanging
  ;; https://github.com/emacs-lsp/lsp-mode/issues/3555#issuecomment-2830321073
  (with-eval-after-load 'lsp-mode
    (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))

  ;; manual template expansion ---

  (defun my/template-expand ()
    (interactive)
    (cond
     ((not (null (tempel-expand)))
      (progn
        (message "Tempel snippet...")
        (call-interactively #'tempel-expand)))
     ((not (null (yas--templates-for-key-at-point)))
      (progn
        (message "Yasnippet snippet...")
        (call-interactively #'yas-expand)))
     (t
      (message "No snippets here"))))

  (:global "M-/" #'my/template-expand
           "C-M-/" #'hippie-expand)

  ;; helper var ---

  ;; helper functions
  (defun my/capf-prepend-local (capfs)
    "Prepend buffer-local capfs with CAPFS."
    (setq-local completion-at-point-functions
                (append capfs completion-at-point-functions)))

  (defun my/capf-override-local (capfs)
    "Override buffer-local capfs with CAPFS."
    (setq-local completion-at-point-functions
                (append capfs '(t))))

  (defvar my/capf-local-default nil
    "The buffer-local original value of the capf variable.")

  (cl-defmacro my/capf-create-mode-setup
      (&key hook
            (func #'my/capf-override-local)
            capfs
            after-load)
    (cl-check-type hook symbol)
    (cl-check-type func symbol)
    (cl-check-type capfs list)
    (let ((body
           `(progn
              ,(let ((new-defun-name
                      (intern
                       (format "my/capf-%s-setup"
                               (symbol-name hook)))))
                 `(add-hook ',hook
                            (defun ,new-defun-name ()
                              (when debug-on-error
                                (message "Debug: running: %S" ',new-defun-name)
                                (message "Debug: capf before: %S" completion-at-point-functions))
                              (,func ,capfs)
                              (when debug-on-error
                                (message "Debug: capf after: %S" completion-at-point-functions))))))))
      (if after-load
          `(with-eval-after-load ',after-load
             ,body)
        body)))

  ;; tweaks ---

  (defun my/capf-prefix-length-2-advice (orig-fun &rest args)
    (cape-wrap-prefix-length orig-fun 2))

  (defun my/capf-prefix-length-5-advice (orig-fun &rest args)
    (cape-wrap-prefix-length orig-fun 5))

  (advice-add 'tempel-complete :around #'my/capf-prefix-length-2-advice)
  (advice-add 'cape-keyword    :around #'my/capf-prefix-length-2-advice)

  (advice-add 'cape-dabbrev    :around #'my/capf-prefix-length-5-advice)

  ;; defining ---

  ;; global defaults (fallback always)
  (setq-default completion-at-point-functions
                (list #'cape-file
                      #'cape-dabbrev
                      ;; #'cape-history ;; annoying minibuffer history?
                      ))

  ;; derived-modes default (specific major-modes usually override)

  (dolist (hook '(prog-mode-hook conf-mode-hook text-mode-hook))
    (add-hook
     hook
     (defun my/capf-derived-mode-setup ()
       (interactive)
       (if (eq major-mode 'java-ts-mode)
           (when debug-on-error
             (message "Debug: major-mode %s excluded from derived mode setup"
                      major-mode))
         (when (local-variable-p 'completion-at-point-functions)
           (setq-local my/capf-local-default
                       (remove 't completion-at-point-functions))
           (when debug-on-error
             (message "Debug: capf local default: %S" my/capf-local-default)
             (message "Debug: capf now: %S" completion-at-point-functions)))
         (my/capf-prepend-local
          (list (cape-capf-super ;; #'yasnippet-capf
                 #'tempel-expand
                 #'cape-keyword)))
         (when debug-on-error
           (message "Debug: after prepending local: %s" my/capf-local-default))))))

  ;; specific major-modes

  ;; elisp
  (my/capf-create-mode-setup
   :hook emacs-lisp-mode-hook
   :capfs
   (list (cape-capf-super #'tempel-complete ;; #'yasnippet-capf
                          #'cape-keyword
                          #'elisp-completion-at-point)))

  ;; eshell
  (my/capf-create-mode-setup
   :hook eshell-mode-hook
   :capfs
   (list (cape-capf-super #'tempel-complete ;; #'yasnippet-capf
                          #'cape-keyword
                          #'pcomplete-completions-at-point)))

  ;; lsp-mode
  (my/capf-create-mode-setup
   :hook lsp-managed-mode-hook
   :after-load lsp-mode
   :capfs
   (list (cape-capf-super #'tempel-complete ;; #'yasnippet-capf
                          (cape-capf-buster
                           #'lsp-completion-at-point))))

  ;; org
  (my/capf-create-mode-setup
   :hook org-mode-hook
   :after-load org
   :capfs
   (list (cape-capf-super #'tempel-complete ;; #'yasnippet-capf
                          #'cape-elisp-block
                          #'pcomplete-completions-at-point)
         #'cape-tex
         #'cape-rfc1345
         #'cape-emoji))

  ;; eglot-java-mode
  (my/capf-create-mode-setup
   :hook eglot-java-mode-hook
   :after-load eglot-java
   :capfs
   (list (cape-capf-super
          #'tempel-complete ;; prefix len: 2
          (cape-capf-prefix-length #'eglot-completion-at-point 2))))
  )

#+end_src

** Hippie-expand

A better dabbrev-expand.

#+begin_src elisp

(setup hippie-exp
  ;; replace dabbrev-expand with hippie-expand
  (global-set-key [remap dabbrev-expand] 'hippie-expand)

  ;; yasnippet integration
  (:with-feature yasnippet
    (:when-loaded
      (add-to-list 'hippie-expand-try-functions-list
                   #'yas-hippie-try-expand)))

  ;; tempel integration
  (:with-feature tempel
    (:when-loaded
      (add-to-list 'hippie-expand-try-functions-list
                   #'tempel-expand))))

#+end_src

** Isearch (TODO: move)

- TODO: replace with hydra, so can use C-M-r for recursive edit.

#+begin_src elisp

(setup isearch
  (:when-loaded
    (:global "C-M-s" isearch-forward
             "C-M-r" isearch-backward)))

#+end_src

* IDE (rewrite, WIP)

** toggle: lsp-mode vs eglot

To ease switching between eglot and lsp-mode, i made a variable.

#+begin_src elisp

(defcustom my/lsp-backend 'lsp-mode
  "Which LSP backend to use."
  :type '(choice
          (const :tag "Eglot" eglot)
          (const :tag "lsp-mode" lsp-mode))
  :group 'my-config)

(defun my/lsp-p ()
  (pcase my/lsp-backend
    ('lsp-mode t)
    ('eglot nil)
    (_ (warn "Invalid value for my/lsp-backend: %s"
             my/lsp-backend))))

(defun my/eglot-p ()
  (pcase my/lsp-backend
    ('lsp-mode nil)
    ('eglot t)
    (_ (warn "Invalid value for my/lsp-backend: %s"
             my/lsp-backend))))

;; unit test
(unless
    (and (let ((my/lsp-backend 'lsp-mode))
           (and (my/lsp-p)
                (not (my/eglot-p))))
         (let ((my/lsp-backend 'eglot))
           (and (my/eglot-p)
                (not (my/lsp-p)))))
  (error "Unit test for my/lsp-backend failed."))


#+end_src

** sane defs

#+begin_src elisp

;; newfile templates
(auto-insert-mode)

;; diminish auto-fill-mode
;; (auto-fill-mode auto-breaks line if too long)
(diminish 'auto-fill-mode)

;; spaces > tabs
(setq-default indent-tabs-mode nil)

;; auto-scroll compilation buffer
(setc compilation-scroll-output t)

;; buttonize urls
(add-hook 'after-init-hook #'global-goto-address-mode)

#+end_src

** parenthesis matching

#+begin_src elisp

(setup elec-pair
  (:require-self)

  ;; disable "<" pair expansion
  (defun my/disable-<-pair-expansion ()
    (setq-local electric-pair-inhibit-predicate
                `(lambda (c)
                   (if (char-equal c ?<)
                       t
                     (,electric-pair-inhibit-predicate c)))))
  (add-hook 'org-mode-hook #'my/disable-<-pair-expansion)

  ;; enable
  (electric-pair-mode 1))

#+end_src

** tooling

*** direnv

#+begin_src elisp

(-setup direnv
  (direnv-mode 1))

;; lorri (extension to direnv)
(defun my/lorri-init ()
  "Run `lorri init` in the current directory and show the output."
  (interactive)
  (when (y-or-n-p "Run `lorri init`? ")
    (shell-command "lorri init")))

#+end_src

*** hex colors

Colorize hex colors.

#+begin_src elisp

(-setup rainbow-mode
  (:diminish)
  (:hook-into prog-mode-hook))

#+end_src

*** colorize ANSI escape sequences

#+begin_src elisp

(with-eval-after-load 'ansi-color
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter))

#+end_src

** project management

*** projectile

Works best with lsp-mode.

#+begin_src elisp

(-setup projectile
  (:only-if (my/lsp-p))

  (projectile-mode +1)
  (:global "C-c p" 'projectile-command-map)
  (:option projectile-compile-use-comint-mode t)
  (:with-map projectile-command-map
    (:bind "c L" #'my/lorri-init)
    (with-eval-after-load 'consult
      (:bind "s r" #'consult-ripgrep))))

;; all-in-one buffers, files, projects (depends on consult)
(-setup consult-projectile
  (:load-after projectile)
  (:with-map projectile-command-map
    (:bind "TAB" #'consult-projectile)))

#+end_src

*** project

Works best with eglot.

#+begin_src elisp

(setup project
  (:only-if (my/eglot-p))

  (defun project-compile-interactive ()
    "Interactively compile with comint."
    (declare (interactive-only compile))
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'project-compile)))
  (:option xref-search-program 'ripgrep)
  (:when-loaded
    (global-set-key (kbd "C-c p") project-prefix-map))
  (:with-map project-prefix-map
    (:bind "C" project-compile-interactive
           "s" consult-ripgrep
           "S" project-shell
           "b" consult-project-buffer)))

;; Note: obsolete, consult-project-buffer is the same?
;; (-setup consult-project-extra
;;   (:load-after consult)
;;   (:require-self)
;;   (:with-map project-prefix-map
;;     (:bind "F" consult-project-extra-find)))

#+end_src

** syntax checkers

*** Flycheck

#+begin_src elisp

(-setup flycheck
  (:only-if (my/lsp-p))

  (:option flycheck-idle-change-delay 0.4
           flycheck-display-errors-delay 0.8)
  (add-hook 'after-init-hook #'global-flycheck-mode)

  (:when-loaded
    (-setup flycheck-inline
      (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))))

#+end_src

*** Flymake

The built-in syntax checker. Integrates well with Eglot, but not with lsp-mode.

#+begin_src elisp

(setup flymake
  (:only-if (my/eglot-p))

  (:option flymake-no-changes-timeout 0.3
           flymake-wrap-around nil
           ;; flymake-show-diagnostics-at-end-of-line t
           ;; flymake-show-diagnostics-at-end-of-line 'fancy
           ;; flymake-show-diagnostics-at-end-of-line 'short
           flymake-show-diagnostics-at-end-of-line nil
           )
  ;; TODO: create hydra for jumping next/prev/diagnostics
  (:with-map flymake-mode-map
    (:bind "C-c ! n" flymake-goto-next-error
           "C-c ! p" flymake-goto-prev-error
           "C-c ! l" flymake-show-diagnostics-buffer)))

#+end_src

** LSP client

*** optimizations

**** Lsp-booster

https://github.com/blahgeek/emacs-lsp-booster

#+begin_src elisp

(setup emacs
  (:only-if (my/lsp-p))

  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command))

#+end_src

**** eglot-booster

Vastly improve the performance of eglot.
https://github.com/jdtsmith/eglot-booster

#+begin_src elisp

;; Note: try experimenting performance difference by running
;; M-x eglot-booster.
(-setup (eglot-booster :host github :repo "jdtsmith/eglot-booster")
  (:only-if (my/eglot-p))
  
  (:load-after elgot)
  (:when-loaded
    (eglot-booster-mode)))

#+end_src

*** Lsp-mode

#+begin_src elisp

(-setup lsp-mode
  (:only-if (my/lsp-p))
  (:option lsp-keymap-prefix "C-c l"     ; keymap
           lsp-completion-provider :none ; supply own capf with cape
           lsp-idle-delay 0.5            ; refresh rate
           ;; If lag, don't update inlay hints on scroll
           ;; ([[https://github.com/emacs-lsp/lsp-mode/issues/4113]])
           ;; lsp-update-inlay-hints-on-scroll nil
           )
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))

(-setup lsp-ui
  (:only-if (my/lsp-p))
  (:load-after lsp-mode)
  ;; -- Sideline --
  (:option lsp-ui-sideline-delay 0.2              ; sideline delay
           lsp-ui-sideline-show-hover nil         ; show hover mesgs
           lsp-ui-sideline-show-code-actions nil) ; show code actions
  ;; -- Peek --
  (:option lsp-ui-peek-always-show nil) ; show ui even if one result
  (:with-map lsp-ui-mode-map
    (:bind [remap xref-find-definitions] lsp-ui-peek-find-definitions
           [remap xref-find-references] lsp-ui-peek-find-references))
  ;; -- Doc --
  (:option lsp-ui-doc-position 'top      ; location of popup
           lsp-ui-doc-delay 0.5          ; popup delay
           lsp-ui-doc-alignment 'frame   ; where to align to(?)
           lsp-ui-doc-show-with-cursor t ; show doc of thing at point
           lsp-ui-doc-show-with-mouse t) ; show doc of thing at mouse
  (:with-map lsp-ui-doc-frame-mode-map
    (:bind "q" lsp-ui-doc-hide
           "u" lsp-ui-doc-unfocus-frame))
  ;; -- imenu --
  (:option lsp-ui-imenu-kind-position 'top      ; vert. alignment
           lsp-ui-imenu-auto-refresh-delay 1.0) ; refresh delay
  ;; misc
  (with-eval-after-load 'lsp-mode
    (:with-map lsp-command-map
      (:bind "v i" #'lsp-ui-imenu))))

#+end_src

*** Eglot

#+begin_src elisp

(setup eglot
  (:only-if (my/eglot-p))
  :disabled

  (:option eglot-report-progress nil)
  (:with-map eglot-mode-map
    (:bind "C-c l a" eglot-code-actions
           "C-c l A" eglot-code-action-quickfix ;; what's this do?
           "C-c l r" eglot-rename
           "C-c l h" eldoc
           "C-c l f" eglot-format
           "C-c l F" eglot-format-buffer
           "C-c l R" eglot-reconnect
           "C-c l n" flycheck-next-error
           "C-c l p" flycheck-previous-error
           "C-c l ?" xref-find-references
           "C-c l ]" xref-go-forward
           "C-c l [" xref-go-back)))

;; -- eglot-x --

;; Eglot does not support extensions to the LSP protocol. This package adds them.
;; https://github.com/nemethf/eglot-x
;;
;; Useful looking functions:
;; - ! eglot-x-expand-macro
;; - ! eglot-x-reload-workspace
;; - ! eglot-x-analyzer-status
;; - ? eglot-x-ask-related-tests
;; - eglot-x-rebuild-proc-macros
;; - eglot-x-run-flycheck
;; - eglot-x-view-recursive-memory-layout

(-setup (eglot-x :host github :repo "nemethf/eglot-x")
  (:only-if (my/eglot-p))

  (:load-after eglot)
  (:when-loaded
    (eglot-x-setup)
    (:with-map eglot-mode-map
      (:bind "C-c l q s" eglot-x-analyzer-status
             "C-c l q R" eglot-x-reload-workspace
             "C-c l q e" eglot-x-expand-macro
             "C-c l q p" eglot-x-rebuild-proc-macros))))

;; -- consult-eglot --

;; An all-in-one consult command to view everything.
;; ((c . "Class") (f . "Function") (e . "Enum") (i . "Interface")
;;  (m . "Module") (n . "Namespace") (p . "Package")
;;  (s . "Struct") (t . "Type Parameter") (v . "Variable")
;;  (A . "Array") (B . "Boolean") (C . "Constant")
;;  (E . "Enum Member") (F . "Field") (M . "Method") (N . "Number")
;;  (O . "Object") (P . "Property") (S . "String") (o . "Other"))

(-setup consult-eglot
  (:only-if (my/eglot-p))

  (:load-after consult eglot)
  (:when-loaded
    (:with-map eglot-mode-map
      (:bind "C-c l s" consult-eglot-symbols))))

;; -- eldoc --

;; show documentation at point
(setup eldoc
  (:only-if (my/eglot-p))

  (:diminish)
  (:option eldoc-echo-area-prefer-doc-buffer t))

;; Pop-up documentation frame for thing at point.
;; https://github.com/casouri/eldoc-box
(-setup eldoc-box
  (:only-if (my/eglot-p))

  (:load-after eglot)
  (:diminish eldoc-box-hover-mode)
  (:option eldoc-box-offset '(16 16 48))
  (add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-mode t))
#+end_src

** Langs

- Lisp
  - all
  - Elisp
  - Scheme
- Nix
- Rust
- Lua
- C
- Java
- Haskell
- Yaml
- HTML
- Typst
- Markdown

*** Lisp

**** for all

#+begin_src elisp

(defvar my/lisp-mode-hooks
  '(emacs-lisp-mode-hook
    lisp-data-mode-hook
    scheme-mode-hook))

;; Colorize matching parens
(-setup rainbow-delimiters
  (:hook-into-all my/lisp-mode-hooks))

;; Structural editing (advanced)
(-setup paredit
  (:diminish)
  (:hook-into-all my/lisp-mode-hooks)
  (:with-map paredit-mode-map
    (:bind "M-r" nil)))

#+end_src

**** Elisp

#+begin_src elisp

(setup emacs-lisp-mode
  (:hook (defun my/emacs-lisp-mode-setup ()
           (auto-fill-mode 1)
           (setq-local fill-column 80)))

  ;; flycheck tweak
  (with-eval-after-load 'flycheck
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc emacs-lisp)))

  ;; support org-style links
  (-setup orglink
    (:hook-into emacs-lisp-mode-hook))

  ;; hide license header
  (setup elide
    (:with-hook emacs-lisp-mode-hook
      (:hook #'elide-head-mode))))

#+end_src

**** Scheme (disabled)

Scheme is a family of Lisp languages, which includes Guile Scheme, a Lisp used for configuring GNU Guix (previous distro).

#+begin_src elisp

;; improved scheme editing
(-setup geiser
  :disabled

  (:match-file "\\.scm\\'")
  (:option geiser-default-implementation 'guile
           geiser-active-implementations '(guile)
           geiser-implementations-alist  '(((regexp "\\.scm$") guile))))

;; improved guile (dialect of scheme) editing
(-setup geiser-guile
  :disabled

  (:load-after geiser))

#+end_src

**** Clojure (disabled)

#+begin_src elisp

(-setup clojure-mode
  :disabled)

#+end_src

*** Nix

#+begin_src elisp

(-setup nix-mode
  (pcase my/lsp-backend
    ('lsp-mode
     (:hook lsp-deferred))
    ('eglot
     (:hook eglot-ensure))))

#+end_src

*** Lua

#+begin_src elisp

(-setup lua-mode
  (:when-loaded
    (with-eval-after-load 'lsp-lua
      ;; fix issue with externally installed server
      (setq lsp-clients-lua-language-server-command
            "lua-language-server")
      ;; renoise lua api definitions
      ;; (setq lsp-lua-workspace-library "'Lua.workspace.library': {'/home/sui/Music/prod/scripts/renoise-lua/definitions': true}")
      (setq lsp-lua-workspace-library (ht ("/home/sui/Music/prod/scripts/renoise-lua/definitions" t)))
      (setq lsp-lua-runtime-plugin "/home/sui/Music/prod/scripts/renoise-lua/definitions/plugin.lua")
      )

    ;; fix pt.2
    (defun my/lsp-clients-lua-language-server-test ()
      "(Improved) Test Lua language server binaries and files."
      (or (and (f-exists? lsp-clients-lua-language-server-main-location)
               (f-exists? lsp-clients-lua-language-server-bin))
          (f-exists? (car (split-string lsp-clients-lua-language-server-command)))))

    (advice-add #'lsp-clients-lua-language-server-test
                :override
                #'my/lsp-clients-lua-language-server-test)))

#+end_src

*** Rust

#+begin_src elisp

(-setup rust-mode
  (:option rust-mode-treesitter-derive t
           rust-rustfmt-switches '("--edition" "2021")))

(-setup rustic
  (:load-after rust-mode)
  (:option rustic-format-on-save t
           rustic-rustfmt-args "--edition 2021"
           rustic-cargo-use-last-stored-arguments t)

  (:with-map rustic-mode-map
    (:bind "C-c C-c M-r" rustic-cargo-comint-run
           "C-c C-c l" flycheck-list-errors
           "C-c C-c A" rustic-cargo-add
           "C-c C-c R" rustic-cargo-rm
           "C-c C-c a" lsp-execute-code-action
           "C-c C-c r" lsp-rename
           "C-c C-c q" lsp-workspace-restart
           "C-c C-c Q" lsp-workspace-shutdown
           "C-c C-c s" lsp-rust-analyzer-status
           "C-c C-c h" lsp-describe-thing-at-point))

  ;; -- Company Integration --

  (with-eval-after-load 'company
    (add-hook 'rust-ts-mode-hook
              (lambda ()
                (setq-local company-idle-delay 0.3
                            company-minimum-prefix-length 2))))

  ;; -- Lsp-mode Integration --

  (setup emacs
    (:only-if (my/lsp-p))
    (:load-after lsp-mode)
    (:option
     ;; linter
     lsp-rust-analyzer-cargo-watch-command "clippy"
     ;; Show func args names
     lsp-rust-analyzer-display-parameter-hints t
     ;; Show hidden reborrows (e.g. &*(&*jargon))
     lsp-rust-analyzer-display-reborrow-hints "never"
     ;; Show hidden lifetimes
     lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial"
     ;; Show hidden lifelimes, show param names, not index
     lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil
     ;; Show closure return type
     lsp-rust-analyzer-display-closure-return-type-hints t
     ;; Show hints for method chains
     lsp-rust-analyzer-display-chaining-hints t)
    (defun my/rust-lsp-hook ()
      (setq-local
       lsp-lens-enable nil
       lsp-idle-delay 0.5             ; ?
       ;; Sideline
       lsp-ui-sideline-delay 0.3
       ;; Doc
       lsp-eldoc-render-all t         ; too much?
       lsp-ui-doc-max-height 13))
    (add-hook 'lsp-mode-hook #'my/rust-lsp-hook))

  ;; -- Eglot Integration --

  (setup emacs
    (:only-if (my/eglot-p))
    (:load-after eglot)
    (:option rustic-lsp-client 'eglot)))

#+end_src

**** Rustowl (disabled)

Note that this doesn't work with Eglot: https://github.com/cordx56/rustowl/issues/16

#+begin_src elisp

;; (-setup (rustowl :host github :repo "lispcat/rustowl-fork")
;;   (:load-after eglot rust-mode)
;;   (:when-loaded
;;     ;; (add-to-list 'eglot-server-programs
;;     ;;              '((rust-mode rust-ts-mode rustic-mode) . ("rustowl")))
;;     ))

#+end_src

*** Java

#+begin_src elisp

(-setup lsp-java
  (:only-if (my/lsp-p))
  (:load-after lsp-mode)

  (:option lsp-java-format-settings-profile "GoogleStyle"
           lsp-java-format-settings-url (expand-file-name
                                         "no-search/java/eclipse-java-google-style.xml"
                                         my/emacs-src-dir))
  (:with-feature java-mode
    (:when-loaded
      (:hook lsp-deferred)
      (:hook auto-fill-mode)
      (:local-set fill-column 100)
      (:bind "<f9>" #'projectile-compile-project)))

  (:with-feature java-ts-mode
    (:when-loaded
      (:hook lsp-deferred)
      (:hook auto-fill-mode)
      (:local-set fill-column 100)
      (:bind "<f9>" #'projectile-compile-project))))


(-setup eglot-java
  (:only-if (my/eglot-p))
  (:load-after eglot)

  (:hook-into java-mode-hook
              java-ts-mode-hook)
  (:with-map eglot-java-mode-map
    (:bind "C-c l l n" eglot-java-file-new
           "C-c l l x" eglot-java-run-main
           "C-c l l t" eglot-java-run-test
           "C-c l l N" eglot-java-project-new
           "C-c l l T" eglot-java-project-build-task
           "C-c l l R" eglot-java-project-build-refresh))
  (:when-loaded
    (setq eglot-java-user-init-opts-fn 'custom-eglot-java-init-opts)
    (defun custom-eglot-java-init-opts (server eglot-java-eclipse-jdt)
      "Custom options that will be merged with any default settings."
      `(:settings
        (:java
         (:format
          (:settings
           (:url ,(concat "file://"
                          (expand-file-name "no-search/java/eclipse-java-google-style.xml"
                                            my/emacs-src-dir)))
           :enabled t)))))
    (add-hook 'eglot-managed-mode-hook
              (defun eglot-connect-hook-cape-capf-fix ()
                (when debug-on-error
                  (message "Debug: running eglot-connect-hook-cape-capf-fix"))
                (when (eq (nth 0 completion-at-point-functions)
                          'eglot-completion-at-point)
                  (pop completion-at-point-functions)))))
  (add-to-list 'my/eglot-override-syntax-checker '(java-ts-mode flymake))
  (add-to-list 'my/eglot-override-syntax-checker '(java-mode flymake))

  (defun my/java-mode-setup (mode)
    (add-hook mode #'eglot-ensure)
    (add-hook mode #'auto-fill-mode)
    (setq-local fill-column 100)
    (define-key (symbol-value (intern (format "%s-map" mode)))
                (kbd "<f9>") #'projectile-compile-project))

  (with-eval-after-load 'java-mode
    (my/java-mode-setup 'java-mode))
  (with-eval-after-load 'java-ts-mode
    (my/java-mode-setup 'java-ts-mode)))
#+end_src

*** C

#+begin_src elisp

(setup cc-mode
  (:when-loaded
    (add-to-list 'c-default-style '(c-mode . "cc-mode"))
    (define-key c-mode-map (kbd "<f8>")
                (pcase my/lsp-backend
                  ('lsp-mode #'projectile-compile-project)
                  ('eglot    #'project-compile-interactive))))
  (:with-hook c-mode-hook
    (when (my/lsp-p)
      (:hook lsp-deferred)
      (:hook (defun my/c-mode-hook ()
               (setq-local lsp-idle-delay 0.1
                           lsp-enable-indentation nil
                           lsp-enable-on-type-formatting nil)
               (c-set-offset 'case-label '+))))
    (when (my/eglot-p)
      (:hook eglot-ensure))))

#+end_src

*** Haskell

#+begin_src elisp

(-setup haskell-mode
  (:match-file ".hs")
  (:with-feature haskell-cabal
    (:match-file ".cabal")))

#+end_src

*** Scala (disabled)

#+begin_src elisp

(-setup scala-mode
  :disabled)

#+end_src

*** YAML

#+begin_src elisp

(-setup yaml-mode)

#+end_src

*** HTML

#+begin_src elisp

(setup sgml-mode
  (:when-loaded
    (:with-map html-mode-map
      ;; remove an intrusive keybind
      (:bind "M-o" nil))))

#+end_src

*** Markdown

#+begin_src elisp

(-setup markdown-mode
  (:match-file "\\.md\\'")
  (:with-mode gfm-mode
    (:match-file "README\\.md\\'" ))

  (:option markdown-fontify-code-blocks-natively t)
  (:when-loaded
    (add-hook 'markdown-mode-hook
              (defun my/setup-markdown-mode ()
                ;; (visual-fill-column-mode 1)
                (display-line-numbers-mode 0)))))

#+end_src

*** Typst

#+begin_src elisp

(-setup (typst-ts-mode :type git :host codeberg :repo "meow_king/typst-ts-mode")
  (:option typst-ts-mode-grammar-location
           (expand-file-name
            "tree-sitter/libtree-sitter-typst.so"
            user-emacs-directory))

  ;; open output pdf in other window
  (defun my/typst-ts-mode-open-pdf ()
    (interactive)
    (let* ((orig-win (selected-window))
           (target-extension "pdf")
           (current-path (buffer-file-name))
           (target-path (file-name-with-extension current-path
                                                  target-extension)))
      (find-file-other-window target-path)
      (select-window orig-win)))
  ;; (add-hook 'typst-ts-mode-hook #'my/typst-ts-mode-open-pdf)
  (:option typst-ts-preview-function #'my/typst-ts-mode-open-pdf)

  ;; auto compile
  ;; (add-hook 'typst-ts-mode-hook #'typst-ts-watch-mode)
  )

#+end_src

*** Kerolox (disabled)

#+begin_src elisp :tangle no

(-setup emacs
  :disabled

  ;; Major-mode for .rp1 files
  (define-derived-mode kerolox-mode prog-mode "kerolox"
    "Major mode for editing kerolox (.rp1) files."
    :group 'kerolox)

  (with-eval-after-load 'lsp-mode
    ;; Register LSP server and setup LSP server
    (add-to-list 'lsp-language-id-configuration '(kerolox-mode . "kerolox"))
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection '("/home/sui/Code/cloned/saturn-v/target/release/saturn-v" "lsp"))
      :major-modes '(kerolox-mode)
      :server-id 'saturn-v-lsp)))

  ;; -- Kerolox treesit mode and LSP --

  (define-derived-mode kerolox-ts-mode kerolox-mode "kerolox[ts]"
    "Tree-sitter based major mode for editing kerolox (.rp1) files."
    :group 'kerolox

    (when (and (fboundp 'treesit-available-p)
               (treesit-available-p))

      ;; create parser for this buffer
      (treesit-parser-create 'kerolox)

      (setq-local treesit-font-lock-feature-list
                  '((comment)
                    (keyword string)
                    (constant type)
                    (function variable module constructor)
                    (operator punctuation)))

      (setq-local font-lock-defaults nil)

      ;; Set up face mapping for tree-sitter query capture names to Emacs faces
      (defvar kerolox-ts-font-lock-settings
        (treesit-font-lock-rules
         :language 'kerolox
         :feature 'comment
         '((comment) @font-lock-comment-face)

         :language 'kerolox
         :feature 'constant
         '((integer) @font-lock-constant-face
           (value (symbol)) @font-lock-constant-face)

         :language 'kerolox
         :feature 'variable
         '((variable) @font-lock-variable-name-face)

         :language 'kerolox
         :feature 'module
         '((import (symbol)) @font-lock-preprocessor-face)

         :language 'kerolox
         :feature 'type
         '((type (symbol)) @font-lock-type-face)

         :language 'kerolox
         :feature 'function
         '((definition relation: (symbol)) @font-lock-function-name-face
           (atom head: (symbol)) @font-lock-function-name-face)

         :language 'kerolox
         :feature 'constructor
         '((rule relation: (symbol)) @font-lock-function-name-face)

         :language 'kerolox
         :feature 'punctuation
         '(([":-" "," "."]) @font-lock-delimiter-face
           (["(" ")"]) @font-lock-bracket-face)

         :language 'kerolox
         :feature 'operator
         '((binary_expr op: (_)) @font-lock-builtin-face
           (unary_expr op: (_)) @font-lock-builtin-face
           (cardinality kind: (_)) @font-lock-builtin-face)

         :language 'kerolox
         :feature 'keyword
         '((["constrain" "decision" "define" "import" "output" "soft"]) @font-lock-keyword-face
           (constraint_kind) @font-lock-keyword-face))
        "Font-lock settings for Kerolox.")

      ;; Set font-lock settings from the defined rules
      (setq-local treesit-font-lock-settings kerolox-ts-font-lock-settings)

      (treesit-major-mode-setup)))

  ;; Register LSP server and setup LSP server
  (with-eval-after-load 'lsp-mode
    (add-to-list 'lsp-language-id-configuration '(kerolox-ts-mode . "kerolox"))
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection '("/home/sui/Code/cloned/saturn-v/target/release/saturn-v" "lsp"))
      :major-modes '(kerolox-ts-mode)
      :server-id 'saturn-v-ts-lsp)))

  ;; -- kerolox - tree-sitter generic --

  (with-eval-after-load 'treesit
    ;; Configure the language grammar source and mapping
    (when (and (fboundp 'treesit-available-p)
               (treesit-available-p))
      ;; Define grammar source
      (add-to-list 'treesit-language-source-alist
                   '(kerolox . ("https://github.com/marceline-cramer/saturn-v" nil "tree-sitter-kerolox/src")))

      ;; ;; Set up language mapping
      ;; (add-to-list 'treesit-language-remap-alist '(kerolox-ts-mode . kerolox))

      ;; Only install if not already installed
      ;; (unless (treesit-language-available-p 'kerolox)
      ;;   (treesit-install-language-grammar 'kerolox))
      (treesit-install-language-grammar 'kerolox)
      ))

  ;; Auto-start LSP when opening .rp1 files with tree-sitter mode
  (add-hook 'kerolox-ts-mode-hook #'lsp-deferred)

  ;; Kerolox misc

  ;; Remap regular mode to tree-sitter mode
  (setq major-mode-remap-alist
        '((kerolox-mode . kerolox-ts-mode)))

  ;; -- Kerolox - Auto-mode-alist --

  ;; Associate file name pattern with major-mode
  (add-to-list 'auto-mode-alist '("\\.rp1\\'" . kerolox-ts-mode)))

#+end_src



** Meta

*** Tree-sitter setup

#+begin_src elisp

(-setup treesit-auto
  (:option treesit-auto-install 'prompt)
  (:autoload global-treesit-auto-mode)
  (global-treesit-auto-mode))

#+end_src

*** Outline

TODO: refactor this (maybe move towards org?)

#+begin_src elisp

;; Optimal folding: https://github.com/jamescherti/outline-indent.el
(-setup outline-indent
  (:diminish outline-minor-mode)
  (:diminish outline-indent-minor-mode)
  (:autoload outline-indent-minor-mode)
  (:option outline-indent-ellipsis " ‣")

  ;; outline-cycle
  (defun my/outline-toggle (&optional univ)
    "Toggle previous heading.

If hide, fold only current heading.
If show, open only current heading.

If ran with Universal Argument, run `my/outline-cycle-buffer' instead."
    (interactive "P")
    ;; go to prev heading
    (outline-back-to-heading)
    ;; universal arg
    (if current-prefix-arg
        (my/outline-cycle-buffer)
      ;; toggle
      (let ((action
             (if (outline-invisible-p (pos-eol))
                 'to-show
               'to-hide)))
        (pcase action
          ('to-hide
           (outline-hide-entry))
          ('to-show
           (outline-show-entry))
          (_ (error "bug"))))))

  (my/defhydra-repeat my/outline-toggle
                    (";" "<backtab>"))

  (defun my/outline-toggle-meta (&optional univ)
    "Toggle subtree at previous heading.

If hide, fold current and all subheadings, and show tree.
If show, open /everything/ under the heading.

If ran with Universal Argument, run `my/outline-cycle-buffer' instead."
    (interactive "P")
    ;; go to prev heading
    (outline-back-to-heading)
    ;; universal arg
    (if current-prefix-arg
        (my/outline-cycle-buffer)
      ;; toggle
      (let ((action
             (if (outline-invisible-p (pos-eol))
                 'to-show
               'to-hide)))
        (pcase action
          ('to-hide
           (outline-hide-subtree)
           (outline-show-branches))
          ('to-show
           (outline-show-subtree))
          (_ (error "bug"))))))

  (my/defhydra-repeat my/outline-toggle-meta
                    (";" "<backtab>"))

  ;; outline-cycle buffer
  (defun my/outline-cycle-buffer (&optional level)
    (interactive (list (when current-prefix-arg
                         (prefix-numeric-value current-prefix-arg))))
    (let (top-level)
      (save-excursion
        (goto-char (point-min))
        (while (not (or (eq top-level 1) (eobp)))
          (when-let ((level (and (outline-on-heading-p t)
                                 (funcall outline-level))))
            (when (< level (or top-level most-positive-fixnum))
              (setq top-level (max level 1))))
          (outline-next-heading)))
      (cond
       (level
        (outline-hide-sublevels level)
        (setq outline--cycle-buffer-state 'all-heading)
        (message "All headings up to level %s" level))
       ((or (eq outline--cycle-buffer-state 'show-all)
            (eq outline--cycle-buffer-state 'top-level))
        (outline-show-all)
        (outline-hide-region-body (point-min) (point-max))
        (setq outline--cycle-buffer-state 'all-heading)
        (message "All headings"))
       (t
        (outline-show-all)
        (setq outline--cycle-buffer-state 'show-all)
        (message "Show all")))))

  (my/defhydra-repeat my/outline-cycle-buffer
                    (";" "<backtab>"))

  ;; special TAB, cycle if on heading
  (defun my/indent-for-tab-command--outline-advice (orig-fn &rest args)
    "Advice for alternative TAB behavior if over outline heading."
    (if (and (eq major-mode 'emacs-lisp-mode)
             (save-excursion
               (beginning-of-line)
               (looking-at "^;;;+ .*$")))
        (my/outline-toggle)
      (apply orig-fn args)))

  (advice-add 'indent-for-tab-command :around
              #'my/indent-for-tab-command--outline-advice)

  ;; run outline-hide-body only after first focus (add to .dir-locals.el)
  ;; (defun my/hide-outline-on-open (func &rest args)
  ;;   "Hide outlines when opening files via dired or projectile."
  ;;   (let ((result (apply func args)))
  ;;     ;; After the file is opened, hide outlines if conditions are met
  ;;     (when (and (buffer-file-name)
  ;;                outline-indent-minor-mode)
  ;;       (outline-hide-body))
  ;;     result))

  ;; (advice-add 'find-file :around #'my/hide-outline-on-open)
  ;; (advice-add 'dired-find-file :around #'my/hide-outline-on-open)
  ;; (advice-add 'projectile-find-file :around #'my/hide-outline-on-open)
  ;; (advice-add 'projectile-find-file-dwim :around #'my/hide-outline-on-open)

  (:with-map outline-minor-mode-map
    (:bind "<backtab>" my/outline-toggle-meta))

  (:with-map emacs-lisp-mode-map
    (:bind "C-c C-n" outline-next-visible-heading
           "C-c C-p" outline-previous-visible-heading))

  (:when-loaded
    (defun my/outline-faces-setup ()
      (dolist (face-config
               '((outline-1 1.9 nil)
                 (outline-2 1.6 nil)
                 (outline-3 1.3 t)
                 (outline-4 1.1 t)
                 (outline-5 1.0 t)
                 (outline-6 1.0 t)
                 (outline-7 1.0 t)
                 (outline-8 1.0 t)))
        (let ((face (nth 0 face-config))
              (height (nth 1 face-config))
              (over (nth 2 face-config)))
          (set-face-attribute face nil :height height :overline over)))
      ;; extras
      (with-eval-after-load 'org
        (set-face-attribute 'org-ellipsis nil :foreground 'unspecified)))
    ;; run now
    (my/outline-faces-setup)
    ;; run after each theme load
    (add-hook 'my/after-enable-theme-hook #'my/outline-faces-setup)

    (progn

      (defvar my-outline-map (make-sparse-keymap)
        "Keymap for outline commands.")

      (dolist (binding
               '(;; buffer
                 (";" . my/outline-cycle-buffer)
                 ("s" . outline-show-all)
                 ("h" . outline-hide-body)
                 ;; subtree
                 ("t" . outline-show-subtree)
                 ("T" . outline-hide-subtree)
                 ;; other/current
                 ("O" . outline-hide-other)
                 ;; children
                 ("c" . outline-show-children)
                 ("C" . outline-hide-children)
                 ;; move
                 ("<up>" . outline-indent-move-subtree-up)
                 ("<down>" . outline-indent-move-subtree-down)
                 ("<right>" . outline-indent-shift-right)
                 ("<left>" . outline-indent-shift-left)
                 ;; navigation
                 ("p" . outline-previous-visible-heading)
                 ("n" . outline-next-visible-heading)
                 ("b" . outline-backward-same-level)
                 ("f" . outline-forward-same-level)))
        (define-key my-outline-map (kbd (car binding)) (cdr binding)))

      ;; Bind the keymap to C-c ;
      (global-set-key (kbd "C-c o o") my-outline-map)))

  ;; buffer
  (:global "C-c o ;" my/outline-cycle-buffer
           "C-c o s" outline-show-all
           "C-c o h" outline-hide-body)

  (:with-hook emacs-lisp-mode-hook
    (:hook (lambda ()
             (outline-indent-minor-mode)
             ;; (setq-local make-window-start-visible t) ;; TODO: see what commenting out does
             (let ((header-comment-p "^\\(;;;+\\) .*"))
               (setq-local outline-regexp header-comment-p)
               (setq-local outline-level
                           (lambda ()
                             (if (looking-at "^\\(;;;+\\) .*")
                                 (- (match-end 1) (match-beginning 1) 2)
                               0)))
               )))))

#+end_src

*** Outline faces

#+begin_src elisp

(-setup outline-minor-faces
  (:load-after outline outline-indent)
  (:with-hook outline-minor-mode-hook
    (:hook outline-minor-faces-mode))
  ;; (progn
  ;;   ;; exclude custom fontlocking for defuns
  ;;   (defun my/outline-minor-faces--exclude-defuns (orig-fn arg)
  ;;     "Remove ^( patterns from the regex argument."
  ;;     (let ((filtered-regex
  ;;            (or (let ((regex "\\|^("))   ; Fixed: escaped the backslash properly
  ;;                  (and (string-search regex arg)
  ;;                       (string-replace regex "" arg))) ; Fixed: "" instead of nil
  ;;                (let ((regex "^(\\|"))                 ; Fixed: escaped properly
  ;;                  (and (string-search regex arg)
  ;;                       (replace-regexp-in-string regex "" arg))) ; Fixed: "" instead of nil
  ;;                (let ((regex "^("))
  ;;                  (and (string-search regex arg)
  ;;                       (replace-regexp-in-string regex "" arg)))))) ; Fixed: "" instead of nil
  ;;       (if filtered-regex
  ;;           (funcall orig-fn filtered-regex)
  ;;         (funcall orig-fn arg))))
  ;;   (advice-add 'outline-minor-faces--syntactic-matcher :around
  ;;               #'my/outline-minor-faces--exclude-defuns))
  )

(-setup backline
  (:load-after outline outline-indent)
  (:when-loaded
    (advice-add 'outline-flag-region :after 'backline-update)))

#+end_src

* Org

Configuration for org-mode.

Org is a markup language and plain text file format, much like Markdown, but a lot more powerful.

** leader-o

For org and outline.

#+begin_src elisp

(leader-bind
  "ol" '(consult-org-heading :wk "org-imenu"))

#+end_src

** basics

#+begin_src elisp

(setup org
  (:option org-directory "~/Notes/org"  ; default org directory

           ;; Startup:
           org-startup-folded 'showall ; default folding mode (def: 'showeverything)
           org-startup-indented t      ; indent with heading depth

           ;; UI
           org-src-window-setup 'current-window ; edit src blocks in the same window
           org-src-preserve-indentation t ; remove leading whitespace in src-blocks
           org-tags-column -45            ; tag indent column
           org-cycle-hide-drawer-startup t ; hide drawers

           ;; Keyboard:
           org-special-ctrl-a/e t       ; better C-a/C-e
           org-return-follows-link t    ; RET can open links

           ;; Visual:
           org-hide-emphasis-markers t  ; hide formatting chars (* / ~ = etc)
           org-ellipsis                 ; custom ellipses when folded
           " ‣"
           ;; " ›"
           ;; " …"
           ;; " ⤵"
           ;; " ▾"
           )
  (:with-map org-mode-map
    (:bind "C-M-<return>"
           (defun +org-meta-ret-meta-right ()
             "Shortcut for M-RET M-<right>."
             (interactive)
             (org-meta-return)
             (org-metaright)))))

#+end_src

** fonts

#+begin_src elisp

(setup org
  (:when-loaded
    (defvar +org-fonts-alist
      '((org-document-title :height 1.9 :weight bold)
        (org-level-1 :height 1.7)
        (org-level-2 :height 1.4)
        (org-level-3 :height 1.15)
        (org-level-4 :height 1.1)))

    ;; (with-eval-after-load 'ef-themes
    ;;   (setq ef-themes-headings +org-fonts-alist))

    ;; (with-eval-after-load 'modus-themes
    ;;   (setq modus-themes-headings +org-fonts-alist))

    ;; (with-eval-after-load 'kaolin-themes
    ;;   (setq kaolin-themes-org-scale-headings nil))

    ;; for each FACE, if not yet set to target, set.
    (defun +org-fonts-setup (&rest _args)
      (interactive)
      (when (eq major-mode 'org-mode)
        (dolist (lst-face +org-fonts-alist)
          (-let* (((t-face . t-args) lst-face)
                  ;; form: '((t-attr (c-val t-val)) ...)
                  (t-attr-c-t-val-alist
                   (->> t-args
                        (-partition 2)
                        (-map (lambda (pair)
                                (-let* (((t-attr t-val) pair)
                                        (c-val (face-attribute t-face t-attr)))
                                  (list t-attr (list c-val t-val)))))))
                  ;; form: '(bool ...)
                  (eq-c-t-lst
                   (->> t-attr-c-t-val-alist
                        (-map (lambda (pair)
                                (-let (((t-attr (c-val t-val)) pair))
                                  (equal c-val t-val))))))
                  ;; form: '(bool ...)
                  (eq-c-t-every?
                   (-all? #'identity eq-c-t-lst)))
            ;; if all cur eq target, then ok
            (if eq-c-t-every?
                (when debug-on-error
                  (message "Log: ok: %S, %S" t-face t-attr-c-t-val-alist))
              ;; else, set to target
              (message "Log: setting: %S, %S" t-face t-attr-c-t-val-alist)
              (apply #'set-face-attribute t-face nil t-args))))))

    ;; (advice-add 'load-theme :after #'+org-fonts-setup)
    ;; (add-hook 'org-mode-hook #'+org-fonts-setup)
    ))

#+end_src

** colorize NEXT face

#+begin_src elisp

(setup org
  ;; colorize "NEXT" todo face
  (:when-loaded
    (defun +org-todo-color-override (&rest _)
      "Set org-todo-keyword-faces only if not already set by the theme."
      (setq org-todo-keyword-faces
            `(("NEXT" . ( :foreground ,(face-foreground 'font-lock-string-face nil)
                          :weight bold
                          :inhert (org-todo)))
              ("PLAN" . ( :foreground ,(face-foreground 'font-lock-function-name-face nil)
                          :weight bold
                          :inhert (org-todo))))))

    (+org-todo-color-override)
    (advice-add 'load-theme :after #'+org-todo-color-override)))

#+end_src

** exclude "<" ">" matching like parens

If using parenthesis-matching modes, usually "<" and ">" are treated as matching pairs. This below excludes them.

#+begin_src elisp

(setup org
  ;; fix syntax "<" ">" matching with paren

  (:when-loaded
    (add-hook 'org-mode-hook
              (lambda ()
                (modify-syntax-entry ?< ".")
                (modify-syntax-entry ?> ".")))))

#+end_src

** syntax highlighting on org-latex exports

#+begin_src elisp

(setup org
  (:option org-latex-src-block-backend 'minted
           org-latex-minted-langs
           '((python "python") (emacs-lisp "common-lisp") (cc "c++")
             (shell-script "bash"))))
#+end_src

** org-toc

Auto-generate table of contents in org-mode buffers.

#+begin_src elisp

(-setup toc-org
  (:hook-into org-mode-hook))

#+end_src

** anki-editor

#+begin_src elisp

(-setup anki-editor
  (:autoload anki-editor-push-note-at-point
             anki-editor-push-notes
             anki-editor-push-new-notes)
  (:option anki-editor-latex-style 'mathjax)
  (:when-loaded
    (defun +ensure-anki-editor-mode (note)
      "Ensure `anki-editor-mode' is enabled before pushing notes."
      (unless anki-editor-mode
        (anki-editor-mode 1)))
    (advice-add #'anki-editor--push-note :before #'+ensure-anki-editor-mode)))

#+end_src

*** scripts

#+begin_src elisp

(defun +org-priority-to-anki ()
  (interactive)
  ;; check connection with anki
  (unless (or (boundp 'anki-editor-mode) anki-editor-mode)
    (anki-editor-mode 1))
  (anki-editor-api-check)
  ;; delete anki_note_type and/or anki_note_id for each w/o a priority
  (save-excursion
    (let ((points-no-priority
           (org-ql-query
            :select #'point-marker
            :from (current-buffer)
            :where
            '(and (not (priority))
                  (or (property "ANKI_NOTE_ID")
                      (property "ANKI_NOTE_TYPE"))))))
      (dolist (p (reverse points-no-priority))
        (goto-char p)
        (when (org-find-property "ANKI_NOTE_ID")
          (anki-editor-delete-note-at-point))
        (when (org-find-property "ANKI_NOTE_TYPE")
          (org-delete-property "ANKI_NOTE_TYPE")))))
  ;; ensure all priority headings have anki_note_type set
  (save-excursion
    (let ((points-yes-priority
           (org-ql-query
            :select #'point-marker
            :from (current-buffer)
            :where '(priority))))
      (dolist (p (reverse points-yes-priority))
        (goto-char p)
        (unless (org-entry-get nil "ANKI_NOTE_TYPE")
          (anki-editor-set-note-type nil "Basic"))))))

#+end_src

** org-tempo (Disabled)

Generate src blocks by typing "<el" then press TAB (but replace "el" with anything).

Usually, src blocks are created with =C-c C-,= or ~org-insert-structure-template~, but that can be slow and tedious.

Disabled for now since [[tempel][tempel]] provides an ~src~ snippet.

#+begin_src elisp

(setup org-tempo
  :disabled

  (:load-after org)
  (:when-loaded
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("gcc" . "src c"))
    (add-to-list 'org-structure-template-alist '("scm" . "src scheme"))
    (add-to-list 'org-structure-template-alist '("conf" . "src conf"))
    (add-to-list 'org-structure-template-alist '("java" . "src java"))
    (add-to-list 'org-structure-template-alist '("unix" . "src conf-unix"))
    (add-to-list 'org-structure-template-alist '("clang" . "src c"))))

#+end_src

** auto-tangle

By adding:
: #+auto_tangle: t
to the top of an org buffer, automatically tangle source blocks on save.

#+begin_src elisp

(-setup org-auto-tangle
  (:hook-into org-mode-hook))

#+end_src

** image-slicing

Slices rendered images in org files such that keyboard scrolling is smooth.

#+begin_src elisp

(-setup (image-slicing :host github :repo "ginqi7/image-slicing")
  (:autoload image-slicing-mode)
  (:hook-into org-mode-hook)
  (:option image-slicing-newline-trailing-text nil))

#+end_src

** Agenda (TODO: tweak, optimize workflow)

#+begin_src elisp

(setup org-agenda
  (:load-after org)

  (:option org-enforce-todo-dependencies t ; DONE iff all subtasks are DONE

           ;; todo keywords
           org-todo-keywords
           `((sequence
              "TODO(t)" "NEXT(n)" "PLAN(p)" "|" "DONE(d/!)"))

           ;; agenda files
           org-agenda-files
           `("~/Notes/denote/20250728T235116--todo__todo.org")

           ;; org tags
           org-tag-alist
           '(;; activities:
             ("@task" . ?t)
             ("@study" . ?s)
             ;; type:
             ("@ongoing" . ?o)
             ;; classes:
             ("@cs2" . ?S)
             ("@bio" . ?B)
             ("@calc2" . ?C)
             ("@phy" . ?P))

           ;; format specification for agenda view
           org-agenda-prefix-format
           `((agenda
              . ,(concat " %i %?-12t "
                         "%-10(+org-get-prop-default) "
                         "% s"))
             (todo . " %i ")
             ;; (tags . " %i %-12:c")
             (tags . " %i ")
             (search . " %c")))

  (defun my/org-agenda-open-agenda-file ()
    (interactive)
    (find-file (car org-agenda-files)))

  (defun my/org-agenda-mark-as-done ()
    (interactive)
    (org-agenda-todo 'done))

  (:global "C-c o a" #'org-agenda
           "C-c o A" #'my/org-agenda-open-agenda-file)
  (:with-map org-agenda-mode-map
    (:bind ")" #'my/org-agenda-mark-as-done))

  ;; helper, used in var `org-agenda-prefix-format' above
  (defun +org-get-prop-default ()
    (apply #'format "[%s] %-2s"
           (let* ((parts-done (+org-get-prop "PARTS_DONE"))
                  (parts-total (+org-get-prop "PARTS_TOTAL"))
                  (fraction (concat (or parts-done "_")
                                    "/"
                                    (or parts-total "_"))))
             (if-let* ((parts-done-num (if (stringp parts-done)
                                           (string-to-number parts-done)
                                         0))
                       (parts-total-num (when (stringp parts-total)
                                          (string-to-number parts-total)))
                       (days-left-num (+org-get-days-left-till-deadline))
                       (parts-left-num (- parts-total-num parts-done-num))
                       (days-behind (- parts-left-num days-left-num))
                       (days-behind-result
                        (cond ((> days-behind 0)
                               (format "-%s" days-behind))
                              (t
                               (format "+%s" (abs days-behind))))))
                 (list days-behind-result fraction)
               (list "  " fraction)))))

  (defun +org-get-days-left-till-deadline ()
    (when-let* ((deadline-abs-day
                 (-some->> (+org-get-prop "DEADLINE")
                   (org-time-string-to-time)
                   (time-to-days)))
                (today-abs-day
                 (-some->> org-agenda-current-date ;; in gregorian
                   (calendar-absolute-from-gregorian)))
                (days-left
                 (- deadline-abs-day today-abs-day)))
      days-left))

  (defun +org-get-prop (prop)
    (when (eq major-mode 'org-mode)
      (let ((val (org-entry-get nil prop)))
        (if (not val) nil
          (format "%s" (string-trim val)))))))

#+end_src

** org-habit

#+begin_src elisp

(setup org-habit
  (:load-after org)
  (:when-loaded
    (add-to-list 'org-modules 'org-habit t)))

#+end_src

** org-super-agenda

#+begin_src elisp

(-setup org-super-agenda
  (:load-after org-agenda)
  (:when-loaded
    (org-super-agenda-mode 1))

  (setq ;; spacemacs-theme-org-agenda-height nil
   ;; org-agenda-time-grid '((daily today require-timed) "----------------------" nil)
   org-agenda-skip-scheduled-if-done t
   org-agenda-skip-deadline-if-done t
   org-agenda-include-deadlines t
   org-agenda-include-diary t
   org-agenda-block-separator nil
   ;; org-agenda-compact-blocks t
   org-agenda-start-with-log-mode t)

  ;; (org-agenda-show-future-repeats nil)
  ;; (org-agenda-start-on-weekday nil)
  ;; (org-agenda-span 'week)
  ;; (org-habit-show-habits nil)
  ;; (org-agenda-skip-deadline-if-done t)
  ;; (org-agenda-skip-scheduled-if-done t)

  ;; (defun ri/pred-test (item)
  ;;   t)

  ;; TODO: fix this so that it works even if goto next day in agenda view!!!
  ;; (defun ri/org-parts-total-deadline-predicate (item)
  ;;   "Return t if PARTS-TOTAL is < days remaining till DEADLINE."
  ;;   (let ((marker (or (get-text-property 0 'org-marker item)
  ;;                     (get-text-property 0 'org-hd-marker item))))
  ;;     (when marker
  ;;       (let* ((parts-total (org-entry-get marker "PARTS_TOTAL"))
  ;;              (parts-total-num (when (and parts-total (stringp parts-total))
  ;;                                (string-to-number parts-total)))
  ;;              (deadline (org-entry-get marker "DEADLINE"))
  ;;              (deadline-time-left
  ;;               (when deadline
  ;;                 (org-time-string-to-time deadline)))
  ;;              (deadline-days
  ;;               (when deadline-time-left
  ;;                 (time-to-days deadline-time-left)))
  ;;              (curr-agenda-day (or (and (bound-and-true-p org-agenda-current-date)
  ;;                                        (time-to-days
  ;;                                         (org-time-from-absolute
  ;;                                          org-agenda-current-date)))
  ;;                                   (org-today)))
  ;;              (days-to-deadline
  ;;               (when deadline-days
  ;;                 (- deadline-days curr-agenda-day))))

  ;;         (cond ((and parts-total-num days-to-deadline)
  ;;                (> parts-total-num (- days-to-deadline 1))))))))

  ;; (defvar ri/org-parts-- )

  (defun ri/org-parts--marker-validate (marker)
    (when (and (markerp marker)
               (buffer-live-p (marker-buffer marker)))
      (with-current-buffer (marker-buffer marker)
        (when (derived-mode-p 'org-mode)
          t))))

  (defun ri/org-parts--marker-get-deadline-time (marker)
    "Return days left till deadline."
    (when (ri/org-parts--marker-validate marker)
      (-some->> (org-entry-get marker "DEADLINE")
        (org-time-string-to-time))))

  (defun ri/org-parts--marker-get-parts-total (marker)
    "Return float if PARTS-TOTAL exists."
    (when (ri/org-parts--marker-validate marker)
      (-some->> (org-entry-get marker "PARTS_TOTAL")
        (string-to-number))))

  (defun ri/org-parts--days-and-parts-state (item)
    (let ((marker (or (get-text-property 0 'org-marker item)
                      (get-text-property 0 'org-hd-marker item))))
      (when-let*
          ((parts (ri/org-parts--marker-get-parts-total marker))
           (deadline (ri/org-parts--marker-get-deadline-time marker)) ;; in abs time
           (deadline-days (time-to-days deadline))
           (today org-agenda-current-date) ;; in gregorian
           (today-days (calendar-absolute-from-gregorian today))
           (days-left (- deadline-days today-days)))
        (let* ((days-lt-parts-p (>= parts (- days-left 1)))
               (days-n-lt-parts-p (not days-lt-parts-p)))
          (list days-lt-parts-p days-n-lt-parts-p)))))

  (defun ri/org-parts--days-lt-parts-predicate (item)
    (nth 0 (ri/org-parts--days-and-parts-state item)))

  (defun ri/org-parts--days-not-lt-parts-predicate (item)
    (nth 1 (ri/org-parts--days-and-parts-state item)))

  (defun ri/org-parts--yes-deadline-no-parts-predicate (item)
    (let ((marker (or (get-text-property 0 'org-marker item)
                      (get-text-property 0 'org-hd-marker item))))
      (and (ri/org-parts--marker-get-deadline-time marker)
           (not (ri/org-parts--marker-get-parts-total marker)))))

  (:option
   ;; add super agenda to org-agenda dispatcher
   ;; TODO: have a thing at the top that shows how many parts i'm behind with in total.
   org-agenda-custom-commands
   `(("a" "Super Agenda"
      ((agenda ""
               ((org-agenda-span 'day)
                (org-agenda-overriding-header "")
                (org-habit-show-habits-only-for-today nil)

                ;; Visible Structure:
                ;; [primary]
                ;; - Overdue [any <- deadline or schedule]
                ;; - Important [any <- priority]
                ;; - DUE TODAY [any <- deadline or schedule]
                ;; [secondary]
                ;; - Today's work [deadline & parts_total]
                ;; - invalid properites [deadline & != parts_total]
                ;; [rest]
                ;;
                (org-super-agenda-groups
                 '(;; Primary
                   (:name "Habit"
                          :order 100
                          :habit t)
                   (:name "Plan"
                          :order 1
                          :todo "PLAN")
                   (:name "Overdue"
                          :order 2
                          :deadline past :scheduled past)
                   (:name "DUE TODAY"
                          :order 3
                          :deadline today :scheduled today)
                   (:name "NEXT"
                          :order 4
                          :todo "NEXT")
                   (:name "Important"
                          :order 5
                          :priority>= "A")
                   ;; Secondary
                   (:name "TODAY'S WORK"
                          :order 6
                          :pred ri/org-parts--days-lt-parts-predicate)
                   (:name "future work"
                          :order 99
                          :discard (:pred ri/org-parts--days-not-lt-parts-predicate))
                   (:name "Unformatted (deadline, no parts)"
                          :order 10
                          :pred ri/org-parts--yes-deadline-no-parts-predicate)
                   (:name "DEBUG: rest"
                          :order 50
                          :anything t)
                   (:discard (:anything t))))))
       (tags "@ongoing"
             ((org-agenda-overriding-header "")
              (org-super-agenda-groups
               '((:name "Ongoing"
                        :anything t)))))))))

  )

#+end_src

** org-ql (disabled)

#+begin_src elisp

(-setup org-ql
  :disabled

  (:load-after org))

#+end_src

** misc functions for org-agenda

#+begin_src elisp

(defun +org-clone-with-fraction (days time effort)
  "Clone subtree with time shifts, prefixing each subheading with fraction prefix."
  (interactive
   (list
    (read-number "How many days to complete it over?: ")
    (read-number "How many minutes do you expect this task to take?: ")
    (read-number "On a scale of 1-10, how much effort will this take?: ")))
  (setq days (1- days))
  ;; create clones
  (org-clone-subtree-with-time-shift days "-1d")
  (org-set-property "TIME" (format "%s" time))
  (org-set-property "EFFORT" (format "%s" effort))
  ;; adjust appropriately
  (save-excursion
    (org-next-visible-heading 1)
    ;; first, sort
    (cl-loop for depth from (1- days) downto 1 do
             (save-excursion
               ;; shift
               (dotimes (_ depth)
                 (org-metadown))))
    ;; add todo and demote
    (save-excursion
      (cl-loop repeat (1- days) do
               (org-next-visible-heading 1))
      (cl-loop for depth from (1- days) downto 0 do
               (let ((frac (format "%d/%d" (1+ depth) days))
                     (time-daily (/ time days)))
                 (org-demote)
                 (let ((org-special-ctrl-a/e t))
                   (org-beginning-of-line))
                 (insert (concat frac " "))
                 (org-set-property "FRACTION" frac)
                 (org-set-property "TIME" (format "%s" time-daily))
                 (org-set-property "EFFORT" (format "%s" effort))
                 (org-next-visible-heading -1))))))

(defun +org-clone-subtasks (effort max-times)
  (interactive
   (list
    (read-number "Effort, on a scale of 1-10: ")
    (read-number "Max times (0 or less for unbound): ")))
  (save-excursion
    ;; get deadline and days till for the heading at point
    (org-back-to-heading)
    (when-let* ((deadline-ts
                 (or (org-entry-get nil "DEADLINE")
                     (user-error "No deadline-ts at point")))
                (days-till-deadline
                 (let ((days
                        (or (org-timestamp-to-now deadline-ts)
                            (user-error "Days till deadline = nil"))))
                   (if (<= max-times 0)
                       ;; unbounded
                       days
                     ;; boundud by max
                     (if (> days max-times)
                         (1+ max-times)
                       days)))))
      ;; set TODO if nil
      (unless (org-entry-get nil "TODO")
        (org-entry-put nil "TODO" "TODO"))

      ;; temporarily set top heading deadline to today
      ;; (org-entry-put nil "DEADLINE"
      ;;                (format-time-string (org-time-stamp-format)))

      ;; delete counting fraction if exists (avoid cloning to below)
      (save-excursion
        (org-end-of-line)
        (let ((org-special-ctrl-a/e t))
          (org-beginning-of-line))
        (when (looking-at "\\[[0-9]*/[0-9]*\\] ")
          (delete-region (point) (match-end 0))))

      ;; extra properties before cloning...
      (org-set-property "EFFORT" (format "%s" effort))

      ;; create subtree clones
      (org-do-demote)
      (org-clone-subtree-with-time-shift (1- days-till-deadline) "-1d")
      ;; note: promote top heading up at the end

      ;; sort deadline of all below
      (save-excursion
        (org-forward-heading-same-level 1)
        (set-mark (line-beginning-position))
        (let ((last-point (point))
              (times 0))
          (while (and (org-forward-heading-same-level 1)
                      (> (point) last-point)
                      (setq last-point (point))
                      (setq times (1+ times))))
          (setq mark-active t)
          (org-sort-entries nil ?d)))

      ;; insert counting fraction at top heading
      (save-excursion
        (org-end-of-line)
        (let ((org-special-ctrl-a/e t))
          (org-beginning-of-line))
        (unless (looking-at "\\[[0-9]*/[0-9]*\\] ")
          (insert "[/] ")))

      ;; ;; revert top heading deadline to deadline-ts
      ;; (org-entry-put nil "DEADLINE" deadline-ts)

      ;; insert fraction in each subheading
      (save-excursion
        (let ((last-point (point))
              (times 0))
          (while (and (org-forward-heading-same-level 1)
                      (> (point) last-point)
                      (setq last-point (point))
                      (setq times (1+ times)))
            (org-end-of-line)
            (let ((org-special-ctrl-a/e t))
              (org-beginning-of-line))
            (insert (format "%s/%s " times (1- days-till-deadline))))))

      ;; promote top heading at top heading
      (org-do-promote)

      ;; visibility folded
      (org-set-property "VISIBILITY" "folded")

      ;; update counting fraction
      (call-interactively #'org-update-statistics-cookies)
      )))

#+end_src

** org-noter

#+begin_src elisp

(-setup org-noter
  (:load-after org)
  (:global "C-c o n" #'org-noter
           "C-c d n" #'org-noter-start-from-dired
           "C-c o p" #'+org-noter-set-prop-current-page)
  (:option org-noter-doc-split-fraction '(0.6 . 0.6))
  (:when-loaded
    (defun +org-noter-set-prop-current-page (arg)
      "Set the property `NOTER_PAGE' of the current org heading to the current noter page.
The property will be removed if ran with a \\[universal-argument]."
      (interactive "P")
      (org-noter--with-selected-notes-window
       (if (equal arg '(4))
           (org-delete-property "NOTER_PAGE")
         (when-let ((vec (org-noter--get-current-view))
                    (num (and (vectorp vec)
                              (> (length vec) 1)
                              (format "%s" (aref vec 1)))))
           (message "meow: %s" num)
           (org-entry-put (point) "NOTER_PAGE" num)))))))

#+end_src

** org-capture (TODO)

#+begin_src elisp

(setup org-capture
  (:load-after org)
  (leader-bind
    "oc" 'org-capture)

  ;; helper for `org-capture-templates', below
  (defun +get-org-agenda-denote-file (name)
    (let ((regex (format "^.*--%s__.*\\.org$" name)))
      (car (seq-filter
            (lambda (path)
              (string-match regex (file-name-nondirectory path)))
            org-agenda-files))))

  (:option org-capture-templates
           `(("t" "Tasks")

             ("td" "Todo with deadline" entry
              (file ,(+get-org-agenda-denote-file "agenda"))
              "* TODO %^{Task}\nDEADLINE: %^{Deadline}t\n%?\n"
              :empty-lines 1
              :immediate-finish nil)

             ("tp" "Task" entry
              (file ,(+get-org-agenda-denote-file "agenda"))
              "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

             ("n" "New note (with Denote)" plain
              (file denote-last-path)
              #'denote-org-capture :no-save t :immediate-finish nil
              :kill-buffer t :jump-to-captured t))))

#+end_src

** org-download

#+begin_src elisp

(-setup org-download
  (:option org-download-image-dir "_images")
  (:load-after org)
  (:when-loaded
    (org-download-enable)))

#+end_src

** visual fill column

#+begin_src elisp

(-setup visual-fill-column
  (with-eval-after-load 'org
    (add-hook 'org-mode-hook
              (defun +org-visual-fill ()
                (setq visual-fill-column-width 100
                      visual-fill-column-center-text t)
                (visual-fill-column-mode 1)))))
#+end_src

** org-bullets

#+begin_src elisp

;; TODO: replace with org-superstar
(-setup org-bullets
  (:hook-into org-mode-hook)
  (:option org-bullets-bullet-list
           '("◉"
             "●"
             "○"
             "■"
             "□"
             "✦"
             "✧"
             "✿")))
#+end_src

** org-modern (disabled)

#+begin_src elisp

(-setup org-modern :disabled
        (:option org-modern-star nil)
        (global-org-modern-mode 1))

#+end_src

** pomodoro

#+begin_src elisp

(-setup org-pomodoro
  (:load-after org))
#+end_src

* Latex

#+begin_src elisp
;;; +latex.el --- latex setup                        -*- lexical-binding: t; -*-

;; Copyright (C) 2025  lispcat

;; Author: lispcat <187922791+lispcat@users.noreply.github.com>
;; Keywords: local

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; 

;;; Code:

;;;; Latex Symbols (Quail)

;; latex symbols
(setup quail
  (eval-after-load "quail/latin-ltx"
    `(progn
       ,@(mapcar (lambda (bind)
                   `(quail-defrule ,(car bind) ,(cdr bind) "TeX"))
                 `(("\\lnt"   . ?¬)
                   ("\\land"  . ?∧)
                   ("\\lor"   . ?∨)
                   ("\\lev"   . ?≡)
                   ("\\nlev"  . ?≢)
                   ("\\lrarr" . ?↔)
                   ("\\bic"   . ?↔)
                   ("\\To"  . ?⇒)
                   ("\\allint" . ?ℤ)
                   ("\\tf" . ?∴)
                   ("\\isct" . ?∩)
                   ("\\ints" . ?∩)
                   ("\\union" . ?∪)
                   ("\\unn" . ?∪)
                   ("\\sst" . ?⊆)
                   ("\\psst" . ?⊂)
                   ("\\nin" . ?∉)
                   ("\\*" . ?·)
                   ("\\boxul"  . ?┌)    ; box upper-left
                   ("\\boxur"  . ?┐)    ; box upper-right
                   ("\\boxdl"  . ?└)    ; box down-left
                   ("\\boxdr"  . ?┘)    ; box down-right
                   ("\\boxh"   . ?─)    ; box horizontal
                   ("\\boxv"   . ?│)    ; box vertical
                   ("\\boxtd"  . ?┬)    ; box tee down
                   ("\\boxtu"  . ?┴)    ; box tee up
                   ("\\boxtr"  . ?├)    ; box tee right
                   ("\\boxtl"  . ?┤)    ; box tee left
                   ("\\boxc"   . ?┼)    ; box cross
                   ;; ("\\vec"   . ?̅)
                   ("\\vec"   . ?̄)
                   ("_y" . ?ᵧ)
                   )))))

;;;; Auctex

(-setup auctex
  (:load-after org)
  (:when-loaded
    ;; comment this out if using in-line latex
    (with-eval-after-load 'ox-latex
      (:option org-latex-compiler "lualatex"
               org-latex-pdf-process
               '("%latex -interaction nonstopmode -output-directory %o %f")))

    ;; larger previews
    (defun preview-larger-previews ()
      (setq preview-scale-function
            (lambda () (* 1.25 (funcall (preview-scale-from-face))))))
    (add-hook 'LaTeX-mode-hook #'preview-larger-previews)))


;;;; CDLaTeX

(-setup cdlatex
  (:load-after auctex)
  (:when-loaded
    (add-hook 'LaTeX-mode-hook #'turn-on-cdlatex)))

;;;; LaTeX preview pane (disabled)

(-setup latex-preview-pane :disabled
        (add-hook 'LaTeX-mode-hook (lambda () (latex-preview-pane-mode 1)))
        (:option pdf-latex-command "lualatex"
                 preview-orientation 'below))

;;;; ox-typst (typst exporter)

;; Documentation: https://github.com/jmpunkt/ox-typst

(-setup ox-typst
  (:load-after org))

#+end_src

* Workspaces

#+begin_src elisp
;; NOTE: modify #'persp-save-state-to-file arg (keep-others-in-non-parametric-file 'yes)

;; maybe have each persp have its own save file, and when autosaving, save each persp?
;; maybe have a function to delete a persp from the main autosave file?
;; - prompt available perspectives from main autosave file, after selection,
;; delete each from file.


;;; Persp-mode

;; TODO: share my hack to the discussions of persp-mode github?

(-setup persp-mode
  ;; keys
  (:global "C-c y" persp-key-map)

  (:with-map persp-key-map
    (:bind "y" #'my-persp-load-name-from-latest
           "d" #'my-persp-delete-name-from-latest))

  ;; vars
  (:option persp-keymap-prefix nil
           wg-morph-on nil              ; animation
           persp-auto-resume-time -1    ; dont autoresume at startup
           persp-auto-save-opt 2)       ; save on shutdown

  ;; hooks
  (add-hook 'after-init-hook #'(lambda () (persp-mode 1)))

  ;; disable completion menu (clashes with which-key)
  ;; manually disable the #'define-prefix-command
  (:when-loaded
    (dolist (it persp-key-map)
      (when (consp it)
        (when (and (consp (cdr it))
                   (stringp (cadr it)))
          (let ((cmd (cddr it)))
            (setcdr it cmd)))))
    (setq persp-key-map (cl-delete-if #'stringp persp-key-map)))

  ;; dont save persp-nil to file
  (:when-loaded
    (set-persp-parameter 'dont-save-to-file t nil))

;;;; consult integration

  (defvar persp-consult-source
    (list :name     "Persp"
          :narrow   ?.
          :category 'buffer
          :state    #'consult--buffer-state
          :history  'buffer-name-history
          :default  t
          :items
          (lambda ()
            (let ((current-persp (get-current-persp)))
              (consult--buffer-query
               :sort 'visibility
               :predicate (lambda (buf)
                            (and current-persp
                                 (persp-contain-buffer-p buf)))
               :as 'buffer-name)))))

  (defvar persp-rest-consult-source
    (list :name     "Other"
          :narrow   ?s
          :category 'buffer
          :state    #'consult--buffer-state
          :history  'buffer-name-history
          :default  t
          :items
          (lambda ()
            (let ((current-persp (get-current-persp)))
              (consult--buffer-query
               :sort 'visibility
               :predicate (lambda (buf)
                            (if current-persp
                                (not (persp-contain-buffer-p buf))
                              t))
               :as 'buffer-name)))))

  (with-eval-after-load 'consult
    (consult-customize consult--source-buffer :hidden t :default nil)
    (add-to-list 'consult-buffer-sources persp-rest-consult-source)
    (add-to-list 'consult-buffer-sources persp-consult-source))

;;;; fix treemacs compatibility bug

  ;; https://github.com/Alexander-Miller/treemacs/issues/1165
  ;; https://github.com/doomemacs/doomemacs/issues/8455

  (advice-add 'treemacs--remove-treemacs-window-in-new-frames :around
              (defun +persp-treemacs-bug-advice (orig-fun &rest args)
                (funcall orig-fun (car-safe args))))

;;;; load and switch to persp by name

  ;; helper
  (defun my-persp--get-non-loaded-names (&optional fname savelist)
    (let* ((available (persp-list-persp-names-in-file
                       fname savelist))
           (loaded (persp-names-current-frame-fast-ordered))
           (non-loaded (seq-remove
                        (lambda (p)
                          (member p loaded))
                        available)))
      non-loaded))

  ;; load name from savefile
  (cl-defun my-persp-load-name-from-latest
      (&optional (fname persp-auto-save-fname)
                 (phash *persp-hash*)
                 (savelist (persp-savelist-from-savefile fname))
                 name)
    "Load and switch to a persp with NAME from latest savefile."
    (interactive)
    ;; debug
    (when nil
      (message "DEBUG: savelist value: %S" savelist))
    ;; with latest file savelist
    (if (not savelist)
        (user-error "no savelist at %s" fname)
      ;; get all non-loaded names from savelist
      (let ((non-loaded (my-persp--get-non-loaded-names fname savelist)))
        (if (not non-loaded)
            (message "no non-loaded persps in %s" fname)
          ;; prompt for name
          (when-let* ((name (or name
                                (persp-read-persp
                                 "to load" nil nil t t nil non-loaded t 'push))))
            ;; load only that persp from the file
            (persp-load-state-from-file fname phash
                                        (regexp-opt (list name))
                                        t savelist)
            ;; switch to persp
            (persp-frame-switch name))))))

;;;; merge persps when saving to file

  ;; don't overwrite backup file with current; merge.
  (advice-add 'persp-save-state-to-file :around
              (cl-defun +persp-save-state-to-file-around-advice
                  (orig-fun
                   &optional
                   (fname persp-auto-save-fname)
                   (phash *persp-hash*)
                   (respect-persp-file-parameter persp-auto-save-persps-to-their-file)
                   keep-others-in-non-parametric-file)
                ;; We need to modify the fourth optional parameter
                (let ((keep-others-in-non-parametric-file 'yes))
                  ;; Call the original function with modified arguments
                  (funcall orig-fun
                           fname phash respect-persp-file-parameter
                           keep-others-in-non-parametric-file))))

;;;; delete persp from savefile

  ;; delete persp from file
  (cl-defun my-persp-delete-name-from-latest
      (&optional (fname persp-auto-save-fname)
                 (savelist (persp-savelist-from-savefile fname))
                 (available-names (persp-list-persp-names-in-file fname savelist))
                 names)
    (interactive)
    (let* ((names (or names
                      (persp-read-persp
                       "to delete" 'reverse nil t nil nil available-names t 'push)))
           (filtered-savelist (cl-remove-if
                               (lambda (expr)
                                 (and (listp expr)
                                      (eq (car expr) 'def-persp)
                                      (seq-contains-p names (cadr expr))))
                               savelist)))
      (if (y-or-n-p (format "Delete %s?" names))
          (persp-savelist-to-file filtered-savelist fname))))

;;;; old remains....

  ;; (:when-loaded
  ;;   (when nil
  ;;     ;; helper functions
  ;;     (defun my/persp--get-names-from-savelist (&optional fname savelist)
  ;;       (let* ((available (persp-list-persp-names-in-file fname savelist))
  ;;              (loaded (persp-names-current-frame-fast-ordered))
  ;;              (unloaded (seq-remove (lambda (p) (member p loaded)) available)))
  ;;         (list available loaded unloaded)))

  ;;     (defun my/persp--prompt-for-persp-name (lst)
  ;;       (when lst
  ;;         (persp-read-persp
  ;;          "to load" nil nil t t nil lst t 'push)))

  ;;     ;; TODO: relocate
  ;;     (defmacro +message-if-debug (format-string &rest args)
  ;;       (when debug-on-error
  ;;         `(message ,format-string ,@args)))

  ;;     ;; load from file
  ;;     (cl-defun my-persp-load-name-from-latest
  ;;         (&optional (fname persp-auto-save-fname)
  ;;                    (phash *persp-hash*)
  ;;                    (savelist (persp-savelist-from-savefile fname))
  ;;                    name)
  ;;       "Load and switch to a perspective via name from the latest backup file."
  ;;       (interactive)
  ;;       ;; prompt for name from available
  ;;       (when savelist
  ;;         (cl-destructuring-bind (available loaded unloaded)
  ;;             (my/persp--get-names-from-savelist fname savelist)
  ;;           (when unloaded
  ;;             (unless name
  ;;               (setq name (my/persp--prompt-for-persp-name unloaded)))
  ;;             (+message-if-debug "DEBUG: > %s\n> %s\n> %s\n> %s"
  ;;                                fname
  ;;                                phash
  ;;                                (regexp-opt (list name))
  ;;                                savelist)
  ;;             (persp-load-state-from-file fname phash
  ;;                                         (regexp-opt (list name))
  ;;                                         t savelist)
  ;;             ;; (persp-frame-switch name)
  ;;             )))

  ;;       ;; (when name
  ;;       ;;   (let ((names-regexp (regexp-opt (list name))))
  ;;       ;;     (persp-load-state-from-file fname phash names-regexp t savelist))
  ;;       ;;   ;; switch to new loaded persp
  ;;       ;;   (persp-frame-switch name))
  ;;       )

  ;;     ;; don't overwrite backup file with current; merge.
  ;;     (advice-add 'persp-save-state-to-file :around
  ;;                 (defun +persp-save-state-to-file-around-advice
  ;;                     (orig-fun &optional fname phash
  ;;                               respect-persp-file-parameter
  ;;                               keep-others-in-non-parametric-file)
  ;;                   ;; We need to modify the fourth optional parameter
  ;;                   (let ((keep-others-in-non-parametric-file 'yes))
  ;;                     ;; Call the original function with modified arguments
  ;;                     (funcall orig-fun
  ;;                              fname phash respect-persp-file-parameter
  ;;                              keep-others-in-non-parametric-file))))


  ;;     ;; delete persp from file
  ;;     (defun my-persp-delete-name-from-latest ()
  ;;       (interactive)
  ;;       (let* ((fname persp-auto-save-fname)
  ;;              (savelist (persp-savelist-from-savefile fname))
  ;;              (available-names (persp-list-persp-names-in-file fname savelist))
  ;;              (names (persp-read-persp
  ;;                      "to delete" 'reverse nil t nil nil available-names t 'push))
  ;;              (filtered-savelist (cl-remove-if
  ;;                                  (lambda (expr)
  ;;                                    (and (listp expr)
  ;;                                         (eq (car expr) 'def-persp)
  ;;                                         (seq-contains-p names (cadr expr))))
  ;;                                  savelist)))
  ;;         (if (y-or-n-p (format "Delete %s?" names))
  ;;             (persp-savelist-to-file filtered-savelist fname))))
  ;;     ))
  )

;;;; wip bridging and auto functionality

;; enable persp-mode-project-bridge mode

;; (when nil
;;   (with-eval-after-load "persp-mode"
;;     (defvar persp-mode-projectile-bridge-before-switch-selected-window-buffer nil)

;;     ;; (setq persp-add-buffer-on-find-file 'if-not-autopersp)

;;     (persp-def-auto-persp
;;      "projectile"
;;      :parameters '((dont-save-to-file . t)
;;                    (persp-mode-projectile-bridge . t))
;;      :hooks '(projectile-before-switch-project-hook
;;               projectile-after-switch-project-hook
;;               projectile-find-file-hook
;;               find-file-hook)
;;      :dyn-env '((after-switch-to-buffer-adv-suspend t))
;;      :switch 'frame
;;      :predicate
;;      #'(lambda (buffer &optional state)
;;          (if (eq 'projectile-before-switch-project-hook
;;                  (alist-get 'hook state))
;;              state
;;            (and
;;             projectile-mode
;;             (buffer-live-p buffer)
;;             (buffer-file-name buffer)
;;             ;; (not git-commit-mode)
;;             (projectile-project-p)
;;             (or state t))))
;;      :get-name
;;      #'(lambda (state)
;;          (if (eq 'projectile-before-switch-project-hook
;;                  (alist-get 'hook state))
;;              state
;;            (push (cons 'persp-name
;;                        (concat "[p] "
;;                                (with-current-buffer (alist-get 'buffer state)
;;                                  (projectile-project-name))))
;;                  state)
;;            state))
;;      :on-match
;;      #'(lambda (state)
;;          (let ((hook (alist-get 'hook state))
;;                (persp (alist-get 'persp state))
;;                (buffer (alist-get 'buffer state)))
;;            (pcase hook
;;              (projectile-before-switch-project-hook
;;               (let ((win (if (minibuffer-window-active-p (selected-window))
;;                              (minibuffer-selected-window)
;;                            (selected-window))))
;;                 (when (window-live-p win)
;;                   (setq persp-mode-projectile-bridge-before-switch-selected-window-buffer
;;                         (window-buffer win)))))

;;              (projectile-after-switch-project-hook
;;               (when (buffer-live-p
;;                      persp-mode-projectile-bridge-before-switch-selected-window-buffer)
;;                 (let ((win (selected-window)))
;;                   (unless (eq (window-buffer win)
;;                               persp-mode-projectile-bridge-before-switch-selected-window-buffer)
;;                     (set-window-buffer
;;                      win persp-mode-projectile-bridge-before-switch-selected-window-buffer)))))

;;              (find-file-hook
;;               (setcdr (assq :switch state) nil)))
;;            (if (pcase hook
;;                  (projectile-before-switch-project-hook nil)
;;                  (t t))
;;                (persp--auto-persp-default-on-match state)
;;              (setcdr (assq :after-match state) nil)))
;;          state)
;;      :after-match
;;      #'(lambda (state)
;;          (when (eq 'find-file-hook (alist-get 'hook state))
;;            (run-at-time 0.5 nil
;;                         #'(lambda (buf persp)
;;                             (when (and (eq persp (get-current-persp))
;;                                        (not (eq buf (window-buffer (selected-window)))))
;;                               ;; (switch-to-buffer buf)
;;                               (persp-add-buffer buf persp t nil)))
;;                         (alist-get 'buffer state)
;;                         (get-current-persp)))
;;          (persp--auto-persp-default-after-match state)))

;;     ;; (add-hook 'persp-after-load-state-functions
;;     ;;           #'(lambda (&rest args) (persp-auto-persps-pickup-buffers)) t)
;;     ))

;; Shows groups for all perspectives. But can't show same buffer in multiple groups.

;; (with-eval-after-load "ibuffer"

;;   (require 'ibuf-ext)

;;   (define-ibuffer-filter persp
;;       "Toggle current view to buffers of current perspective."
;;     (:description "persp-mode"
;;                   :reader (persp-prompt nil nil (safe-persp-name (get-frame-persp)) t))
;;     (find buf (safe-persp-buffers (persp-get-by-name qualifier))))

;;   (defun persp-add-ibuffer-group ()
;;     (let ((perspslist (mapcar #'(lambda (pn)
;;                                   (list pn (cons 'persp pn)))
;;                               (nconc
;;                                (cl-delete persp-nil-name
;;                                           (persp-names-current-frame-fast-ordered)
;;                                           :test 'string=)
;;                                (list persp-nil-name)))))
;;       (setq ibuffer-saved-filter-groups
;;             (cl-delete "persp-mode" ibuffer-saved-filter-groups
;;                        :test 'string= :key 'car))
;;       (push
;;        (cons "persp-mode" perspslist)
;;        ibuffer-saved-filter-groups)))

;;   (defun persp-ibuffer-visit-buffer ()
;;     (interactive)
;;     (let ((buf (ibuffer-current-buffer t))
;;           (persp-name (get-text-property
;;                        (line-beginning-position) 'ibuffer-filter-group)))
;;       (persp-switch persp-name)
;;       (switch-to-buffer buf)))

;;   (define-key ibuffer-mode-map (kbd "RET") 'persp-ibuffer-visit-buffer)

;;   (add-hook 'ibuffer-mode-hook
;;             #'(lambda ()
;;                 (persp-add-ibuffer-group)
;;                 (ibuffer-switch-to-saved-filter-groups "persp-mode"))))

;;; Activities

(-setup activities :disabled
  (:option
   ;; only show tab bar if more than 3 activities open
   tab-bar-show 3)

  (activities-mode)
  (activities-tabs-mode)
  ;; prevent edebug default bindings from interfering
  ;; (setq edebug-inhibit-emacs-lisp-mode-bindings t)

  ;; create map
  (defun +activities-define-existing ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'activities-define)))

  (defvar activities-mode-map
    (let ((map (make-sparse-keymap)))
      ;; Define keys in bulk
      (dolist
          (binding
           '(;; create new activity name.
             ("N" . activities-new)
             ;; define new activity's default with current frame state.
             ;; (prefix) define pre-existing activity' default with current frame state.
             ("d" . +activities-define-existing)
             ;; resume suspended activity
             ;; (prefix) resume activity with default state.
             ("." . +activities-resume-custom)
             ;; ("s" . +activities-resume-custom)
             ("s" . activities-resume)
             ;; save and close activity.
             ;; ("k" . activities-suspend)
             ;; reset to default state and close activity.
             ("c" . activities-kill)
             ;; switch to an opened activity
             ;; ("s" . activities-switch)
             ;; permanently delete activity
             ("k" . activities-discard)
             ;; switch to a buffer in the current activity.
             ("b" . activities-switch-buffer)
             ;; revert activity to default state.
             ("g" . activities-revert)
             ;; list activities in vtable buffer
             ("l" . activities-list)
             ;; rename activity
             ("R" . activities-rename)
             ;; next tab
             ("n" . tab-next)
             ;; previous tab
             ("p" . tab-previous)))
        (define-key map (kbd (car binding)) (cdr binding)))
      ;; set up autoloads
      (let ((cmds (mapcar #'cdr (cdr map))))
        (dolist (c cmds)
          (unless (fboundp c)
            (autoload c "activities" nil t))))
      ;; return map
      map))

  ;; bind map
  (global-set-key (kbd "C-c .") activities-mode-map)
  (global-set-key (kbd "C-c x") activities-mode-map)

;;;; consult integration

  (defun activities-local-buffer-p (buffer)
    "Returns non-nil if BUFFER is present in `activities-current'."
    (when (activities-current)
      (memq buffer
            (activities-tabs--tab-parameter
             'activities-buffer-list
             (activities-tabs--tab (activities-current))))))

  (defvar activities-consult-source
    `(:name "Activity"
            :narrow   ?a
            :category buffer
            :face     consult-buffer
            :history  buffer-name-history
            :state    ,#'consult--buffer-state
            :default  t
            :enabled  ,#'activities-current
            :items ,(lambda () (consult--buffer-query
                           :predicate #'activities-local-buffer-p
                           :sort 'visibility
                           :as #'buffer-name)))
    "Activities local buffers candidate source for `consult-buffer'.")

  (defvar activities-rest-consult-source
    `(:name "Other"
            :narrow   ?o
            :category buffer
            :face     consult-buffer
            :history  buffer-name-history
            :state    ,#'consult--buffer-state
            :enabled  ,#'activities-current
            :items ,(lambda () (consult--buffer-query
                           :predicate (lambda (buf)
                                        (not (activities-local-buffer-p buf)))
                           :as #'buffer-name)))
    "Other buffers candidate source for `consult-buffer'.")

  ;; TODO: slows down projectile find file?
  (with-eval-after-load 'consult
    (consult-customize consult--source-buffer :hidden nil :default nil
                       :name "Buffers" :narrow ?b
                       :enabled (lambda () (not (activities-current))))
    (add-to-list 'consult-buffer-sources activities-rest-consult-source)
    (add-to-list 'consult-buffer-sources activities-consult-source))

;;;;; fix: consult-buffer previews

  (when nil
    (with-eval-after-load 'consult
      (defun +consult-buffer--frame-buffers-around (orig-fn &rest args)
        (let ((_log t)
              (result nil))
          (if-let* ((_predicates (and activities-mode
                                      activities-tabs-mode
                                      tab-bar-mode
                                      (activities-current)))
                    (current-tab (tab-bar--current-tab))
                    (tab-index (tab-bar--current-tab-index))
                    (init-tab-buffers (alist-get 'activities-buffer-list current-tab)))
              ;; if-let then form
              (unwind-protect
                  (setq result (apply orig-fn args))
                ;; re-fetch current tab after consult-buffer
                (let* ((updated-tab (tab-bar--current-tab))
                       (post-tab-buffers
                        (seq-filter #'buffer-live-p
                                    (alist-get 'activities-buffer-list updated-tab)))
                       (current-buffer (current-buffer))
                       ;; remove new temp buffers from post-tab-buffers
                       (filtered-new
                        (seq-filter (lambda (buf)
                                      (and buf
                                           (or (member buf init-tab-buffers)
                                               (eq buf current-buffer)
                                               (equal (buffer-name buf)
                                                      " *Minibuf-1*"))))
                                    post-tab-buffers)))
                  ;; debugging
                  (when _log
                    (message "LOG: activities: ignore consult-buffer previews: %S"
                             (mapcar #'buffer-name
                                     (seq-remove (lambda (x) (member x filtered-new))
                                                 post-tab-buffers))))
                  ;; update the tab's activities-buffer-list
                  (let ((tabs (funcall tab-bar-tabs-function)))
                    (setf (alist-get 'activities-buffer-list (nth tab-index tabs))
                          filtered-new))

                  result))
            ;; if-let else form
            (apply orig-fn args))))

      (advice-add #'consult-buffer :around #'+consult-buffer--frame-buffers-around)))

;;;;; feat: frame restore (disabled)

  ;; ;; helper variable
  ;; (defvar +activities--last-name nil)

  ;; ;; save activities before deleting frame
  ;; (add-to-list 'delete-frame-functions
  ;;              (lambda (frame)
  ;;                (setq +activities--last-name (activities-current))
  ;;                (activities-save-all)))
  ;; ;; save activities before killing emacs
  ;; (add-hook 'kill-emacs-hook #'activities-save-all)

  ;; ;; resume last activity when creating frame
  ;; (add-hook 'after-make-frame-functions
  ;;           (lambda (frame)
  ;;             (when +activities--last-name
  ;;               (with-selected-frame frame
  ;;                 (activities-resume +activities--last-name)))))

;;;;; feat: resume-custom

  (cl-defun +activities-resume-custom (activity &key resetp)
    "Wrapper around `activities-resume'.

When prompted, it excludes activities that are active in other frames.
After evaluating, it suspends all non-current activities."
    (interactive
     (list (activities-completing-read
            :activities (+activities--exclude-other-frames)
            :prompt "Resume activity" :default nil)
           :resetp current-prefix-arg))
    (when-let* ((current (activities-current)))
      (activities-suspend (activities-current)))
    (let ((result (apply #'activities-resume
                         activity
                         (when resetp (list :resetp resetp)))))
      ;; after apply
      (+activities--suspend-not-cur)
      result))

  ;; helper function
  (defun +activities--exclude-other-frames ()
    "Return loadable activities, excluding already active in other frames."
    (let* ((log nil)
           ;; activities loadable from file
           (activities-loadable (-map #'car-safe activities-activities))
           ;; activities active in any frame except current
           (activities-active-in-other
            (->>
             (frame-list)
             (--remove (equal it (selected-frame)))
             (-mapcat
              (lambda (frame)
                (with-selected-frame frame
                  (let ((active-names
                         (->>
                          activities-activities
                          (-filter (-compose #'activities-activity-active-p
                                             #'cdr))
                          (-map #'car-safe))))
                    (prog1 active-names
                      (when log
                        (message "LOG: active-names: %S" active-names))
                      (unless (or (<= 1 (length active-names))
                                  (not active-names))
                        (warn "Expected no more than 1 activity in frame %s: %s"
                              frame active-names)))))))
             (-non-nil)
             (-uniq))))
      ;; from loadable, remove active-in-other
      (when log
        (message "LOG: activities-loadable: %S" activities-loadable)
        (message "LOG: activities-active-in-other: %S" activities-active-in-other))
      (->> activities-loadable
           (--remove (-contains? activities-active-in-other
                                 it))
           (--map (cons it (activities-named it))))))

  ;; helper function
  (cl-defun +activities--suspend-not-cur (&rest _args)
    "Suspend all non-current activities."
    (when-let*
        ((fn-get-active-lst
          (lambda () (->> activities-activities
                     (-filter (-compose #'activities-activity-active-p #'cdr))
                     (-map #'car-safe))))
         (active-lst (funcall fn-get-active-lst))
         (current (activities-activity-name (activities-current)))
         (not-current-lst
          (->> active-lst (--remove (equal current it)))))
      ;; suspend all non-current activities
      (--each not-current-lst
        (activities-suspend (activities-named it)))
      ;; assert expected length and current-value
      (setq active-lst (funcall fn-get-active-lst))
      (unless (<= 1 (length active-lst))
        (warn "expected 1 or 0 length for active-lst: %s"
              active-lst)
        (when (and (= 1 (length active-lst))
                   (equal current (car active-lst)))
          (warn "expected 1 elem of %s, got %S"
                current (car active-lst))))))

;;;;; misc

  )

;;; Perspective

(-setup perspective
  :disabled

  (persp-mode)

  (:option persp-mode-prefix-key (kbd "C-c ."))
  (:global "C-c ." perspective-map)
  (:with-map perspective-map
    (:bind "S" persp-state-save
           "M-s" persp-state-save
           "C-s" nil))
  (add-hook 'kill-emacs-hook #'persp-state-save)
  (:when-loaded
    ;; default backup file
    (setq persp-state-default-file
          (file-name-concat persp-save-dir "persp-auto-save"))
    ;; prev/next buffers
    (setq switch-to-prev-buffer-skip
          (lambda (win buff bury-or-kill)
            (not (persp-is-current-buffer buff))))
    ;; consult-buffer
    (with-eval-after-load 'consult
      (consult-customize consult--source-buffer :hidden nil :default nil)
      (add-to-list 'consult-buffer-sources persp-consult-source))

    ;; save activities before deleting frame
    (add-to-list 'delete-frame-functions
                 (lambda (frame)
                   (persp-save-state)))
    ;; save activities before killing emacs
    (add-hook 'kill-emacs-hook #'persp-save-state)))

#+end_src

* Programs

#+begin_src elisp

(-setup eat
  (:option eat-term-name "xterm-256color"
           eat-kill-buffer-on-exit t)
  ;; :defer-config
  ;; (setq eat-shell (concat (or explicit-shell-file-name
  ;;                             (getenv "ESHELL")
  ;;                             shell-file-name)
  ;;                         " -c tmux"))
  (:global "C-c i a" eat)
  (:with-map eat-semi-char-mode-map
    (:bind "M-o" ace-window)))

(setup eshell
  (:global "C-c i e" eshell))

(-setup magit
  ;; :preface (elpaca transient) ; hack: magit needs newer version
  (:option magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (:global "C-c v" magit))

(-setup pdf-tools
  (:when-loaded
    (pdf-loader-install)))

(-setup elfeed
  ;; set `elfeed-feeds' to all files in `+elfeed-feeds-dir'.
  (:when-loaded
    (defvar +elfeed-feeds-dir "~/feeds")
    (defun +elfeed-feeds-update-var ()
      (interactive)
      (setq elfeed-feeds
            (mapcar (lambda (s) (concat "file:" s))
                    (directory-files +elfeed-feeds-dir t
                                     directory-files-no-dot-files-regexp))))
    ;; run `+elfeed-feeds-update-var' before running `elfeed-update'
    (advice-add #'elfeed-update :before #'+elfeed-feeds-update-var)))
#+end_src

* UI

#+begin_src elisp
;;; +ui.el --- ui improvements                       -*- lexical-binding: t; -*-

;; Copyright (C) 2025  lispcat

;; Author: lispcat <187922791+lispcat@users.noreply.github.com>
;; Keywords: local

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; UI improvements.

;;; Code:

;;;; Fontconfig

;; https://devfonts.gafi.dev/

(defun +fontconfig ()
  (set-face-attribute
   'default nil :font
   ;; "Hack"
   ;; "-Misc-TamzenForPowerline-regular-normal-normal-*-16-*-*-*-c-80-iso10646-1"
   ;; "-UW  -Ttyp0-regular-normal-normal-*-17-*-*-*-m-*-iso8859-1"
   ;; "-UW-Ttyp0-bold-normal-normal-*-17-*-*-*-c-90-iso8859-1"
   ;; "-UW  -Ttyp0-regular-normal-normal-*-16-*-*-*-m-*-iso8859-1"
   ;; "-UW  -Ttyp0-regular-italic-normal-*-16-*-*-*-m-*-iso10646-1"
   ;; "-AW-Greybeard 16px-regular-normal-normal-*-16-*-*-*-c-80-iso10646-1"
   ;; "Fira Code"
   ;; "Maple Mono"
   ;; "Jetbrains Mono"
   ;; "Iosevka"
   ;; "Iosevka-11"
   ;; "Iosevka-11"
   ;; "Iosevka Custom"
   "Iosevka Custom-11"
   ;; "Iosevka NFM-11"
   ;; "Iosevka NFP-11"
   ;; "Iosevka Extended"
   ;; "Aporetic Sans Mono"
   ;; "Aporetic Sans Mono-11"
   ;; "Aporetic Serif Mono"
   ;; "Aporetic Serif Mono-11"
   ;; "Rec Mono Casual"
   ;; "Rec Mono Duotone"
   ;; "Rec Mono Linear"
   ;; "Rec Mono Semicasual"
   ;; "Recursive"
   ;; "Recursive Mn Csl St"
   ;; "Recursive Mn Lnr St"
   )
  (set-face-attribute
   'variable-pitch nil :font
   ;; "Aporetic Sans-11"
   ;; "Aporetic Serif-11"
   ;; "Iosevka-11"
   ;; "Iosevka NFP-13"
   ;; "Iosevka Custom"
   "Iosevka Custom-11"
   ;; "Recursive Sn Csl St"
   ;; "Recursive Sn Lnr St"
   ))

(+fontconfig)

;; Hack: fix bitmap fonts on emacsclient frames
(add-hook 'server-after-make-frame-hook #'+fontconfig)

;; enable variable-pitch-mode by default in org-mode
(with-eval-after-load 'org
  (add-hook 'org-mode-hook #'variable-pitch-mode))

;;;; All the icons

;; all the icons
(-setup all-the-icons
  (:when-loaded
    ;; Use 'prepend for the NS and Mac ports or Emacs will crash.
    (set-fontset-font t 'unicode (font-spec :family "all-the-icons") nil 'append)
    (set-fontset-font t 'unicode (font-spec :family "file-icons") nil 'append)
    (set-fontset-font t 'unicode (font-spec :family "Material Icons") nil 'append)
    (set-fontset-font t 'unicode (font-spec :family "github-octicons") nil 'append)
    (set-fontset-font t 'unicode (font-spec :family "FontAwesome") nil 'append)
    (set-fontset-font t 'unicode (font-spec :family "Weather Icons") nil 'append)))

;;;; Ligatures

(-setup ligature
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (let ((all-ligatures
         '(;; line arrows
           "-<<" "-<" "-<-" "<--" "<---" "<<-" "<-" "->" "->>" "-->" "--->"
           "->-" ">-" ">>-"
           ;; double arrows
           "=<<" "=<" "=<=" "<==" "<===" "<<=" "<=" "=>" "=>>" "==>" "===>"
           "=>=" ">=" ">>="
           ;; two-way arrows
           "<->" "<-->" "<--->" "<---->" "<=>" "<==>" "<===>" "<====>" "::"
           ":::" "__"
           ;; slashes
           "<~~" "</" "</>" "/>" "~~>" "==" "!=" "/=" "~=" "<>" "===" "!=="
           "!===" "=/=" "=!="
           ;; carrots
           "<:" ":=" "*=" "*+" "<*" "<*>" "*>" "<|" "<|>" "|>" "<." "<.>" ".>"
           "+*" "=*" "=:" ":>"
           ;; wrap
           "(*" "*)" "/*" "*/" "[|" "|]" "{|" "|}" "++" "+++" "\\/" "/\\" "|-"
           "-|" "<!--" "<!---")))
    (ligature-set-ligatures 'prog-mode all-ligatures)
    (ligature-set-ligatures 'org-mode all-ligatures))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))

;;;; Themes

;;;;; Function: sets a random theme.

(defun +set-random-theme ()
  "Set a random theme."
  (interactive)
  (let* ((available-themes (custom-available-themes))
         (current-theme (car custom-enabled-themes))
         (themes-except-current (remove current-theme available-themes))
         (chosen-theme (nth (random (length themes-except-current))
                            themes-except-current)))
    ;; disable all enabled themes
    (mapc #'disable-theme custom-enabled-themes)
    ;; enable randomly chosen theme
    (if (custom-theme-p chosen-theme)
        (enable-theme chosen-theme)
      (load-theme chosen-theme :no-confirm))
    ;; mesg
    (message "Enabled theme: %s" chosen-theme)))

;; Install themes

;; fav themes:
;; - ef-owl
;; - ef-dream

(-setup kaolin-themes
  (:require-self))
(-setup ef-themes
  (:require-self)
  (:option ef-dream-palette-overrides
           '((bg-space "#2a272c"))))
(-setup doom-themes
  (:require-self)
  (:option doom-themes-enable-bold t  ; if nil, bold is universally disabled
           doom-themes-enable-italic t)) ; if nil, italics is universally disabled

(setup emacs
  (:load-after doom-themes kaolin-themes ef-themes)
  (:global "C-c T t" consult-theme
           "C-c T r" +set-random-theme)
  (:when-loaded
    (+set-random-theme)))

;;;; Transparency

(defvar +transparency-value 100)

(defun +native-transparency-supported? ()
  "Whether native-transparency is supported on this version of Emacs."
  (if (version<= "29" emacs-version)
      t
    (message "Native transparency is not supported.")
    nil))

(defun +toggle-transparency ()
  "Toggle transparency with `+transparency-value'."
  (interactive)
  (when (+native-transparency-supported?)
    (let ((alpha (frame-parameter nil 'alpha-background)))
      (set-frame-parameter
       nil 'alpha-background
       (if (eql (cond ((numberp alpha) alpha)
                      ((numberp (cdr alpha)) (cdr alpha))
                      ;; Also handle undocumented (<active> <inactive>) form.
                      ((numberp (cadr alpha)) (cadr alpha)))
                100)
           +transparency-value
         100)))))

(defun +set-transparency (value)
  "Set the transparency of the frame window to VALUE."
  (interactive "nTransparency Value 0 - 100 opaque: ")
  (when (+native-transparency-supported?)
    (set-frame-parameter (selected-frame) 'alpha-background value)))

;;;; Line numbers

;; list of programming modes to disable line-numbers on
(defvar +display-line-numbers-exclude '())

;; enable line-numbers on programming modes
(add-hook 'prog-mode-hook
          (lambda ()
            (unless (memq major-mode +display-line-numbers-exclude)
              (display-line-numbers-mode 1))))

(setq display-line-numbers-type 'relative)

;;;; Visual line mode

(global-visual-line-mode 1)
(diminish 'visual-line-mode) ; hide "Wrap" in mode-line

;;;; show whitespace

(setup whitespace
  (:diminish whitespace-mode)
  (:option whitespace-trailing 'whitespace-hspace)

  (defvar +base-whitespace-style '(face trailing tabs missing-newline-at-eof))
  (defun +prog-mode-whitespace ()
    (setq whitespace-style (append +base-whitespace-style '(tab-mark)))
    (whitespace-mode 1))
  (defun +org-mode-whitespace ()
    (setq whitespace-style (append +base-whitespace-style '()))
    (whitespace-mode 1))

  (add-hook 'prog-mode-hook #'+prog-mode-whitespace)
  (add-hook 'org-mode-hook #'+org-mode-whitespace)
  (add-hook 'text-mode-hook #'+org-mode-whitespace))

;;;; Solaire mode

;; (leaf solaire-mode
;;   :config
;;   (defun real-buffer-p ()
;;     (or (solaire-mode-real-buffer-p)
;;         (equal (buffer-name) "*dashboard*")))
;;   (setq solaire-mode-real-buffer-fn #'real-buffer-p)

;;   (solaire-global-mode +1))

;;;; Spacious padding

(-setup spacious-padding
  (:require-self)
  (:option spacious-padding-widths
           (plist-put spacious-padding-widths :header-line-width 0)
           spacious-padding-widths
           (plist-put spacious-padding-widths :mode-line-width 0))
  ;; (spacious-padding-mode 1)
  )

;;;; Mode-line

;; (add-to-list 'load-path
;;              (file-name-concat +emacs-submodules-dir
;;                                "cat-line"))

;; show column # on modeline
(column-number-mode 1)

;;;;; cat-line (mode-line framework)

(setup cat-line
  (:require-self)
  (cat-line-mode 1))

;;;;; custom segments

;; helper segments:

(defun +mode-line-half-space ()
  (propertize " "
              'display '((space :relative-width 0.5))))

(defun +mode-line-tall-space ()
  (let ((top (propertize " " 'display `(raise 0.2)))
        (bot (propertize " " 'display `(raise ,(- 0.25)))))
    (propertize (concat top " " bot))))

(defvar +mode-line-empty
  `(((+mode-line-tall-space))))

(defface +mode-line-doc-face-no-slant
  '((t font-lock-doc-face (:slant normal)))
  "Basically `font-lock-doc-face' but with no slant.")

;; segments:

(defun +mode-line-segment-persp-name ()
  (propertize (format-mode-line persp-lighter)
              'face 'shadow))

(defun +mode-line-segment-pdf-page ()
  (when (eq major-mode 'pdf-view-mode)
    (let ((page-current (image-mode-window-get 'page))
          (page-total (pdf-cache-number-of-pages)))
      (propertize (format "%d/%d " page-current page-total)
                  'face 'shadow))))

(defun +mode-line-segment-cursor-position ()
  (propertize (format-mode-line "%l:%c")
              'face 'shadow))

(defun +mode-line-segment-scroll ()
  (or (+mode-line-segment-pdf-page)
      (propertize (format-mode-line "%p%")
                  'face 'shadow)))

(defun +mode-line-get-project-root ()
  (when-let*
      ((path
        (or
         ;; project?
         (and (fboundp 'project-current)
              (when-let* ((project (project-current)))
                (expand-file-name
                 (if (fboundp 'project-root)
                     (project-root project)
                   (car (with-no-warnings
                          (project-roots project)))))))
         ;; projectile?
         (and (bound-and-true-p projectile-mode)
              (projectile-project-root)))))
    ;; if project path, then abbreviate it
    (abbreviate-file-name path)))

(defun +mode-line-segment-buffer-name ()
  (if-let* ((buffer-path buffer-file-name)
            (project-root (+mode-line-get-project-root))
            (project-name (file-name-nondirectory
                           (directory-file-name project-root))))
      (concat
       ;; project directory
       (propertize (concat project-name "/")
                   'face
                   ;; `((:weight normal) mode-line-buffer-id)
                   `((:weight normal) mode-line-emphasis)
                   ;; `(mode-line-emphasis)
                   )
       ;; relative path
       (propertize (when-let*
                       ((relative-path
                         (file-relative-name
                          (or (file-name-directory
                               (or (abbreviate-file-name buffer-path)
                                   buffer-path))
                              "./")
                          project-root)))
                     (if (string= relative-path "./")
                         ""
                       (substring (shrink-path--dirs-internal relative-path t)
                                  1)))
                   'face `(font-lock-string-face))
       ;; file name
       (propertize (file-name-nondirectory buffer-path)
                   'face `((:inherit bold) mode-line-buffer-id)))
    ;; fallback
    (propertize (buffer-name)
                'face `mode-line-buffer-id)))

(defvar +mode-line-segment-meow-state-alist
  `((normal "[N]" . (success (:inherit bold)))
    (insert "[I]" . (font-lock-keyword-face (:inherit bold)))
    (beacon "[B]" . (warning (:inherit bold)))
    (keypad "[K]" . (mode-line (:inherit bold)))
    (motion "[M]" . (+mode-line-doc-face-no-slant (:inherit bold)))))

(defun +mode-line-segment-meow-state ()
  (when (bound-and-true-p meow--current-state)
    (let ((icon-face-pair (alist-get meow--current-state
                                     +mode-line-segment-meow-state-alist)))
      (concat (propertize (car icon-face-pair)
                          'face (cdr icon-face-pair))))))

;;;;; Doom Modeline

(-setup doom-modeline :disabled
        ;; configuration
        (setq doom-modeline-height 30
              doom-modeline-modal-icon t
              doom-modeline-icon t
              doom-modeline-persp-icon nil
              doom-modeline-bar-width 4
              )

        (add-hook 'after-init-hook #'doom-modeline-mode)

        (:when-loaded
          ;; hide bar
          (set-face-attribute 'mode-line-inactive nil
                              :foreground (face-background 'mode-line-inactive))

          ;; custom modeline
          (doom-modeline-def-modeline 'my-line
            '(eldoc
              bar
              window-state
              workspace-name
              window-number
              modals
              matches
              follow
              buffer-info
              remote-host
              buffer-position
              word-count
              parrot
              selection-info)
            '(compilation
              objed-state
              misc-info
              project-name
              persp-name
              battery
              grip irc
              mu4e
              gnus
              github
              debug
              repl
              lsp
              minor-modes
              input-method
              indent-info
              ;; buffer-encoding
              major-mode
              process
              vcs
              check
              time))
          ;; enable
          (add-hook 'doom-modeline-mode-hook
                    (lambda ()
                      (doom-modeline-set-modeline 'my-line 'default))))

        ;; (:option doom-modeline-height 30
        ;;          doom-modeline-icon nil)

        ;; (:when-loaded
        ;;   ;; custom modeline
        ;;   (doom-modeline-def-modeline 'my-simple-line
        ;;     '(eldoc window-state workspace-name window-number modals matches follow buffer-info remote-host buffer-position word-count parrot selection-info)
        ;;     '(compilation objed-state misc-info project-name persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs check time))

        ;;   ;; set
        ;;   (add-hook 'doom-modeline-mode-hook
        ;;             (lambda ()
        ;;               (doom-modeline-set-modeline 'my-simple-line 'default)))

        ;;   ;; enable
        ;;   ;; (doom-modeline-mode 1)
        ;;   )
        ;; (setq-default header-line-format '("%e" (:eval (doom-modeline-format--main))))
        ;; (setq-default mode-line-format nil)
        ;; (add-hook 'doom-modeline-mode-hook
        ;;           (lambda ()
        ;;             (setq-default mode-line-format nil)
        ;;             (dolist (buf (buffer-list))
        ;;               (with-current-buffer buf
        ;;                 (when mode-line-format
        ;;                   (setq mode-line-format nil))))))

        ;; (add-hook '+after-enable-theme-hook
        ;;           (lambda ()
        ;;             (unless mode-line-format
        ;;               (setq-default mode-line-format nil))))

        ;; :config
        ;; (setq doom-modeline-modal-icon nil)
        ;; (dolist (pair '((doom-modeline-vcs-default . "purple")
        ;;                 (doom-modeline-vcs . "purple")
        ;;                 (doom-modeline-meow-normal-state . "DarkOrchid4")))
        ;;   (let ((face (car pair))
        ;;         (color (cdr pair)))
        ;;     (set-face-attribute face nil :foreground color)))
        )

(-setup doom-modeline
  (:require-self))

;;;;; Mood-line

;; TODO: denote buffer formatting...

(-setup mood-line
  (:require-self)
  ;; (mood-line-mode 1) ;; DISABLED

  ;; if broken, run this:
  ;; (mood-line--process-format mood-line-format)

  ;; hide if not selected
  (advice-add 'mood-line--process-format :around
              (defun mood-line--process-format--advice (orig-fun &rest args)
                (if (mode-line-window-selected-p)
                    (apply orig-fun args)
                  (apply orig-fun (list +mode-line-empty)))))

  ;; glyphs
  (defconst mood-line-glyphs-custom
    '((:checker-info . ?↳)
      (:checker-issues . ?→)
      (:checker-good . ?✓)
      (:checker-checking . ?⟳)
      (:checker-errored . ?x)
      (:checker-interrupted . ?=)

      (:vc-added . ?+)
      (:vc-needs-merge . ?⟷)
      (:vc-needs-update . ?↓)
      (:vc-conflict . ?x)
      (:vc-good . ?✓)

      (:buffer-narrowed . ?◢)
      (:buffer-modified . ?●)
      (:buffer-read-only . ?■)

      (:frame-client . ?)

      (:count-separator . ?×))
    "Set of ASCII glyphs for use with mood-line.")

  (setq mood-line-glyph-alist mood-line-glyphs-unicode)

  ;; printing format
  (setq custom-mood-line-format
        (mood-line-defformat
         :left
         (" "
          ((+mode-line-segment-meow-state)           . " ")
          ((or (mood-line-segment-buffer-status) "") . " ")
          ((+mode-line-segment-buffer-name)          . "  ")
          ;; ((mood-line-segment-buffer-name)           . "  ")
          ((mood-line-segment-anzu)                  . "  ")
          ((mood-line-segment-multiple-cursors)      . "  ")
          ((+mode-line-segment-scroll)               . " ")
          ((+mode-line-segment-cursor-position)       . " ")
          (+mode-line-tall-space))
         :right
         (((mood-line-segment-misc-info)   . "  ")
          ((+mode-line-segment-persp-name) . "   ")
          ;; (+mode-line-half-space)
          ((mood-line-segment-vc)          . "  ")
          ((mood-line-segment-major-mode)  . "  ")
          ((mood-line-segment-checker)     . "  ")
          ((mood-line-segment-process)     . "  ")))

        mood-line-format custom-mood-line-format))

;;;;; Nano modeline (disabled)

;; nano theme and modeline

;; (-setup (nano-theme :host github :repo "rougier/nano-theme"))

(-setup (nano-modeline :host github :repo "rougier/nano-modeline") :disabled
        (:require-self))

(-setup (nano-modeline :host github :repo "rougier/nano-modeline") :disabled
        (:require-self)
        (setq-default mode-line-format nil)
        (defun +nano-modeline-setup-faces ()
          (face-spec-set
           'nano-modeline-active
           `((t (
                 :foreground ,(face-foreground 'default)
                 :background ,(face-background 'mode-line)
                 :box (:line-width 1 :color ,(face-background
                                              'default))))))
          (face-spec-set
           'nano-modeline-inactive
           `((t (
                 :foreground ,(face-foreground 'default)
                 :background ,(face-background 'mode-line-inactive)
                 :box (:line-width 1 :color ,(face-background
                                              'default))))))
          (face-spec-set
           'nano-modeline-status
           `((t (
                 ;; :inherit mode-line-highlight
                 :foreground ,(face-background 'mode-line-inactive)
                 :background ,(face-foreground 'default)
                 :box (:line-width 1 :color ,(face-background
                                              'default)))))))
        (+nano-modeline-setup-faces)
        (add-hook '+after-enable-theme-hook #'+nano-modeline-setup-faces)

        ;; configs

        (defun +nano-modeline-current-mode (&optional name)
          (let ((name (or name (car-safe mode-name))))
            (propertize (format-mode-line name)
                        'face (nano-modeline-face 'secondary))))

        (defun +nano-modeline-current-persp (&optional name)
          (let ((name (or name persp-lighter)))
            (propertize (format-mode-line name)
                        'face (nano-modeline-face 'secondary))))

        (defun +nano-modeline-cursor-position (&optional format)
          (let ((format (or format "%l:%c %p%% ")))
            (propertize (format-mode-line format)
                        'face (nano-modeline-face 'secondary))))

        (defun +nano-modeline--meow-state ()
          (when (boundp 'meow--current-state)
            (let ((mode-cons (alist-get meow--current-state
                                        '((normal "<N>" . success)
                                          (insert "<I>" . font-lock-keyword-face)
                                          (beacon "<B>" . warning)
                                          (motion "<M>" . +mode-line-doc-face-no-slant)
                                          (keypad "<K>" . mode-line)))))
              (concat (propertize (car mode-cons)
                                  'face (cdr mode-cons))))))

        (defun +nano-modeline-buffer-status (&optional status padding)
          (let* ((padding (or padding nano-modeline-padding))
                 (top (propertize " " 'display `(raise ,(car padding))))
                 (bot (propertize " " 'display `(raise ,(- (cdr padding)))))
                 (meow (delete ?> (delete ?< (+nano-modeline--meow-state)))))
            (propertize (concat top (or status meow) bot)
                        'face (nano-modeline-face 'status-RO))
            ;; (cond (buffer-read-only
            ;;        (propertize (concat top (or status "RO") bot)
            ;;                    'face (nano-modeline-face 'status-RO)))
            ;;       ((buffer-modified-p)
            ;;        (propertize (concat top (or status "**") bot)
            ;;                    'face (nano-modeline-face 'status-**)))
            ;;       (t
            ;;        (propertize (concat top (or status "RW") bot)
            ;;                    'face (nano-modeline-face 'status-RW))))
            ))

        (defun +nano-modeline-prog-mode (&optional default)
          (funcall nano-modeline-position
                   '((+nano-modeline-buffer-status) " "
                     (nano-modeline-buffer-name) " "
                     (nano-modeline-git-info))
                   '((+nano-modeline-current-persp) "  "
                     (+nano-modeline-current-mode) "  "
                     (+nano-modeline-cursor-position)
                     (nano-modeline-window-dedicated))
                   default))

        ;;   ;; (setq nano-modeline-position )
        (add-hook 'prog-mode-hook            #'+nano-modeline-prog-mode)
        (add-hook 'text-mode-hook            #'+nano-modeline-prog-mode)
        ;; (add-hook 'text-mode-hook            #'nano-modeline-text-mode)
        (add-hook 'org-mode-hook             #'nano-modeline-org-mode)
        (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
        ;;   (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode)
        ;;   (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode)
        ;;   (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
        ;;   (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
        ;;   (add-hook 'term-mode-hook            #'nano-modeline-term-mode)
        ;;   (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode)
        ;;   (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode)
        ;;   (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode)
        ;; (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode)
        )

;; (-setup (feline :host github :repo "chee/feline-mode")
;;   (feline-mode 0)
;;   (:option feline-line-prefix "L"
;;            feline-column-prefix "C"
;;            feline-mode-symbols
;;            '(emacs-lisp-mode "λ"
;;                              python-mode "py"
;;                              typescript-mode "ts"
;;                              rustic-mode "🦀"
;;                              rust-mode "🦀"
;;                              zig-mode "🦎"
;;                              scheme-mode "🐔")))

;;;;; Custom Modeline (disabled)

;; (-setup mood-line
;;   (:require-self))

;; (setup emacs :disabled
;;   (defvar +mode-line-format--default (get 'mode-line-format 'standard-value))

;;   (defgroup +mode-line-constructs nil
;;     "Mode line constructs.")

;;   (defun +mode-line--get-major-mode ()
;;     (format " %s "
;;             (capitalize
;;              (symbol-name major-mode))))

;;   (defcustom +mode-line-major-mode
;;     '(:eval
;;       (when (mode-line-window-selected-p)
;;         (list
;;          (propertize " λ" 'face 'shadow)
;;          (propertize (+mode-line--get-major-mode)
;;                      'face '((t))))))
;;     "Mode line construct for displaying the major mode."
;;     :group '+mode-line-constructs
;;     :risky t)

;;   (defun +mode-line--get-buffer-name ()
;;     (format " %s " (buffer-name)))

;;   (defcustom +mode-line-buffer-name
;;     '(:eval
;;       (when (mode-line-window-selected-p)
;;         (propertize (+mode-line--get-buffer-name)
;;                     'face '((t :inherit bold)))))
;;     "Mode line construct for displaying the buffer name."
;;     :group '+mode-line-constructs
;;     :risky t)

;;   (defvar +mode-line--to-format
;;     '(("%e"
;;        +mode-line-buffer-name)
;;       (+mode-line-major-mode)))

;;   (defun +mode-line--get-mode-line ()
;;     (let* ((left-str (car +mode-line--to-format))
;;            (right-str (cadr +mode-line--to-format))
;;            (reserve (length (format-mode-line (mapcar #'symbol-value (cadr +mode-line--to-format))))))
;;       `(,@left-str
;;         (:eval
;;          (propertize " "
;;                      'display `((space :align-to (- right ,right-len)))))
;;         ,@right-str)))

;;   (defun +mode-line--get-mode-line ()
;;     (let* ((left-str (car +mode-line--to-format))
;;            (right-str (cadr +mode-line--to-format))
;;            (reserve (length (format-mode-line right-str))))
;;       `(,@left-str
;;         (:eval
;;          (propertize " "
;;                      'display `((space :align-to (- right ,reserve)))))
;;         ,@right-str)))

;;   (setq-default mode-line-format (+mode-line--get-mode-line))

;;   (force-mode-line-update))

;;;; Scroll

;; Improve scroll
(setup emacs
  (global-so-long-mode 1)
  (:option scroll-preserve-screen-position t ; keep point in same position while scrolling
           scroll-conservatively 101 ; dont move cursor when point leaves the screen
           ;; scroll-conservatively 0      ; move cursor when point leaves the screen
           scroll-margin 3           ; scroll when 3 from end
           ;; scroll-margin 0           ; scroll when touch end
           scroll-step 1 ; smooth, step-by-step scrolling
           ;; scroll-step 0    ; no smoothing
           auto-window-vscroll nil        ; faster for long lines
           fast-but-imprecise-scrolling t ; faster for image and overlays
           mouse-wheel-scroll-amount
           '(2                                     ; faster vscroll speed
             ((shift) . hscroll)                   ; S-<scroll> for hscroll
             ((meta) . nil)                        ; M-<scroll> for PgUp/PgDn
             ((control) . text-scale)              ; C-<scroll> for zoom
             ((control meta) . global-text-scale)) ; C-M-<scroll> for global zoom
           mouse-wheel-scroll-amount-horizontal 2  ; faster hscroll speed
           ;; auto-window-vscroll nil ; TODO: what does this do?
           ))

;;;; Dashboard

(-setup dashboard
  :disabled

  (:require-self)
  (setq dashboard-items '((recents . 5)))
  (setq dashboard-center-content t)
  (when (< (length command-line-args) 2)
    (add-hook 'window-size-change-functions #'dashboard-resize-on-hook 100)
    (add-hook 'window-setup-hook #'dashboard-resize-on-hook)
    (add-hook 'after-init-hook
              (lambda ()
                (if (get-buffer "*Warnings*")
                    (setq initial-buffer-choice (lambda () (get-buffer "*Warnings*")))
                  (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
                  (dashboard-insert-startupify-lists)
                  (dashboard-initialize))))))

;;;; prettify symbols

(setup prog-mode
  (global-prettify-symbols-mode 1))

;;;; fireplace

(-setup fireplace)
#+end_src

** leader-T

#+begin_src elisp

(leader-bind
  "T" '(:ignore t :wk "Themes")
  "Tt" '(consult-theme :wk "load-theme"))

#+end_src

** load-theme-hook

A hook that runs after enabling a theme.

#+begin_src elisp

(setup emacs
  (defvar my/load-theme-hook nil)

  (defun my/run-load-theme-hook (&rest _args)
    (run-hooks 'my/load-theme-hook))

  (advice-add 'enable-theme :after #'my/run-load-theme-hook))

#+end_src

* Misc

#+begin_src elisp
(setup server
  (:require-self)
  (:global "C-c q" delete-frame
           "C-c Q" save-buffers-kill-emacs)
  (defun +start-server-if-not-running ()
    "Start the Emacs server if not running."
    (unless (or (processp server-process)
                (server-running-p))
      (server-start)
      (message "Emacsclient Server started!")))
  ;; :hook
  ;; (emacs-startup-hook . +start-server-if-not-running)
  )

(-setup htmlize)

(-setup simple-httpd)

(-setup impatient-mode)
#+end_src

* To-sort

#+begin_src elisp
(setup cus-edit
  (:with-map Custom-mode-map
    (:bind "n" next-line
           "p" previous-line)))

(-setup omni-quotes
  (:diminish)
  (omni-quotes-mode 1)
  (:global "M-s q m" omni-quotes-mode
           "M-s q p" omni-quotes-prev-set
           "M-s q n" omni-quotes-next-set
           "M-s q s" omni-quotes-shuffle-current-set
           "M-s q q" omni-quotes-display-random-quote)
  (:option omni-quotes-idle-interval 60
           omni-quotes-fading t
           omni-quotes-fading-delay 30)
  (:when-loaded
    (omni-quotes-load-simple-quote-file "~/Notes/org/quotes.txt" "personal")))

;; (defvar eldoc-doc-buffer-separator
;;   (concat (propertize "\n" 'face '(:inherit separator-line :extend t)))
;;   "String used to separate items in Eldoc documentation buffer.")


;;; Packages to install (check source code for malware for each first):

;; bind-map

;; restart-emacs

;; golden-ratio

;; ws-butler

;; flycheck-package

;; org-present

;; emacs-purpose

;; origami

;; cask

;; tao-theme

;; emacs-color-themes

;; hydra !!! so good
;; https://github.com/abo-abo/hydra/wiki/Hydras-by-Topic

;; literate programming?

;; hl-todo

;; breadcrumb?

;; git-gutter?

;; hideshow-org?

;; wgrep

;; look into different window strengths, lower C-h e 's strength

;; undo-tree

;; hyperbole

;; tree sitter

;; eglot?

(defhydra hydra-outline (:color red :columns 3)
  "Org Mode Movements"
  ("n" (lambda ()
         (interactive)
         (mapc #'call-interactively
               '(outline-hide-body
                 outline-next-visible-heading
                 outline-show-entry))
         (recenter-top-bottom 1))
   "next heading")
  ("p" (lambda ()
         (interactive)
         (mapc #'call-interactively
               '(outline-hide-body
                 outline-previous-visible-heading
                 outline-show-entry))
         (recenter-top-bottom -1))
   "prev heading")
  ("N" (lambda ()
         (interactive)
         (mapc #'call-interactively
               '(outline-hide-body
                 outline-forward-same-level
                 outline-show-entry))
         (recenter-top-bottom 1))
   "next heading at same level")
  ("P" (lambda ()
         (interactive)
         (mapc #'call-interactively
               '(outline-hide-body
                 outline-backward-same-level
                 outline-show-entry))
         (recenter-top-bottom -1))
   "prev heading at same level")
  ("u" outline-up-heading "up heading")
  ("TAB" (lambda ()
           (interactive)
           (if (outline-invisible-p (pos-eol))
               (mapc #'call-interactively
                     '(outline-hide-body
                       +outline-toggle))
             (mapc #'call-interactively
                   '(outline-hide-body))))
   "toggle heading")
  ("C-p" outline-previous-visible-heading "next")
  ("C-n" outline-next-visible-heading "prev")
  ("C-b" outline-backward-same-level "next samelvl")
  ("C-f" outline-forward-same-level "prev samelvl")
  ("g" org-goto "goto" :exit t))

(leader-bind
  "oH" #'hydra-outline/body)

;; https://www.reddit.com/r/emacs/comments/ioenk2/ical_import_in_emacs_calendar/

(require 'diary-lib)

(setq +calendars
      (with-temp-buffer
        (insert-file-contents "~/Private/elisp/calendar-urls.el")
        (read (current-buffer))))

(defun +ical-pull-all ()
  (interactive)
  (find-file diary-file)
  (erase-buffer)
  (message "Cleared diary file")
  (mapcar (lambda (url)
            (let ((tmpfile (url-file-local-copy url)))
              (message "Importing ")
              (icalendar-import-file tmpfile diary-file)
              (kill-buffer (car (last (split-string tmpfile "/"))))))
          +calendars))

;; no cover
;; (use-package listen)

;; emms extract metadata?
;; https://www.reddit.com/r/emacs/comments/981khz/emacs_music_player_with_emms/

;; TODO:
(-setup emms
  (:when-loaded
    (emms-all)

    (setq emms-player-list '(
                             emms-player-mpd
                             emms-player-mpv
                             ))

    ;; (require 'emms-player-mpv) ; disabled for mpd

    ;; variables

    (setq emms-source-file-default-directory "~/Music/library/")
    (setq emms-player-mpd-music-directory "~/Music/library/")

    ;; emms-player-mpv-parameters '("--no-audio-display=no"); broken
    (setq emms-browser-covers #'emms-browser-cache-thumbnail-async)
    ;; sort by natural order
    (setq emms-playlist-sort-function #'emms-playlist-sort-by-natural-order)
    ;; make streams update metadata
    (setq emms-player-mpv-update-metadata t)
    ;; playlist format use m3u
    (setq emms-source-playlist-default-format 'm3u)
    ;; show format
    (setq emms-show-format "NP: %s")
    ;; ;; sort album by natural order
    ;; ;; (setq  emms-browser-album-sort-function #'emms-playlist-sort-by-natural-order)
    ;; this actually sorts by natural order upon adding
    (add-hook 'emms-playlist-source-inserted-hook
              #'emms-playlist-sort-by-natural-order)

    ;; backends


    ;; get info from mpd
    ;; (add-to-list 'emms-info-functions 'emms-info-mpd)
    ;; ? show current song when next song starts?
    ;; (add-hook 'emms-player-started-hook #'emms-show)
    ;; connect to mpd
    ;; (setq emms-player-mpd-server-name "localhost")
    ;; (setq emms-player-mpd-server-port "6600")
    ;; (setq emms-player-mpd-music-directory "\~/Music/library")
    ;; (emms-player-mpd-connect)

    ;; persistent playlists
    ;; (require 'emms-history)
    (emms-history-load)

    ;; display
    (emms-mode-line-mode 0)

    ;; enable playerctl pausing

    ;; DISABLE LATER when using mpd-mpris service
    ;; (require 'emms-mpris)
    ;; (emms-mpris-enable) ;; (will make emacs hog mpris media playing active)

    ;; (setq emms-player-list '(emms-player-mpd))
    (add-to-list 'emms-info-functions 'emms-info-mpd)
    (add-to-list 'emms-player-list 'emms-player-mpd)

    ;; browser

    ;; TODO: add this function to emms-info-functions (hard to implement?)
    ;; (instead make my own function that runs ffprobe and gets info? might be better)
    (defun +emms-show-album-cover-in-emacs ()
      (interactive)
      (if-let ((track (emms-playlist-current-selected-track))
               (song-path (emms-track-get track 'name))
               (cover-path "/tmp/emms-album-cover.jpg")) ;; is jpg fine?
          (if (not (file-exists-p song-path))
              (message "Error: cannot find path to currently playing song")
            (when (file-exists-p cover-path)
              (delete-file cover-path))
            (let ((exit-code
                   (shell-command
                    (message "extracting: %s"
                             (format "ffmpeg -i %s -an -vcodec copy %s -y"
                                     (shell-quote-argument song-path)
                                     (shell-quote-argument cover-path))))))
              (cond ((/= exit-code 0)
                     (message "Error: ffmpeg cover extraction failed with code %s"
                              exit-code))
                    ((file-exists-p cover-path)
                     (with-current-buffer (get-buffer-create "*Album Cover*")
                       (erase-buffer)
                       (insert-image (create-image cover-path))
                       (pop-to-buffer (current-buffer))))
                    (t
                     (message "Error: ffmpeg cover at cover-path not found.")))))
        (message "No song currently playing")))

    ;; Hook to display album cover in Emacs when the track changes
    ;; (add-hook 'emms-player-started-hook 'emms-show-album-cover-in-emacs)

  ;;;; Personal functions for features: ;;;;

    ;; Edit a playlist:
    ;; - steps:
    ;;   - create a new playlist buffer named "%s_real".
    ;;   - make modifications as needed.
    ;;   - command to write and delete buffer.
    ;; - create a function to reload the playlist from file, as well as write.
    ;; - indicator to show whether the playlist has been modified or not?
    ;;
    ;; Add a song to a playlist:
    ;; - steps:
    ;;   - create a new playlist buffer named "%s_real".
    ;;   - place the song at the bottom of the playlist.
    ;;   - make modifications as needed.
    ;;   - command to write and delete buffer.
    ;;
    ;;
    ;; workflow:
    ;; - idea: if playing a playlist (any) and i want to add a song from it to a specific playlist (regardless of if it's loaded or not), the process is to load the playlist from the file in a new buffer, make the change, save, then close. And for convenience, if that playlist i added the song in is loaded and i wanna see those changes be updated, run a function to reload the playlist from its source file.
    ;;
    ;; Ideas:
    ;; - playlist editing mode?
    ;; - edit one playlist at a time? bc need to preserve the source playlist file somewhere
    ;; - does a playlist file regenerate from the file when opened?
    ;; - command: `emms-playlist-editor-open-playlist'
    ;;   - emms-metaplaylist-mode-new-buffer (to create new buffer with buffer-name
    ;;   -
    ;;
    ;;
    ;; Implement:
    ;; - function: add a playlist file to a new playlist buffer ("%s_EDITING")

    ;;   (require 'cl-lib)

    ;;   (defvar emms-playlist-editor--buffer-name "EDITING"
    ;;     "The buffer name for editing.")

    ;;   (defvar emms-playlist-editor--current-path nil
    ;;     "The filepath to the current \"EDITING\" file.
    ;; Used in `emms-playlist-edit-open-playlist'.")

    ;;   (defun emms-playlist-editor-open-playlist ()
    ;;     (interactive)
    ;;     (let* ((buffer-name emms-playlist-editor--buffer-name)
    ;;         (buffer-real (get-buffer buffer-name)))
    ;;       ;; handle case if buffer already exists
    ;;       (when buffer-real
    ;;      (switch-to-buffer buffer-real)
    ;;      (if (yes-or-no-p (format "Buffer \"%s\" already exists. Delete and contiune?"
    ;;                               buffer-name))
    ;;          (kill-buffer buffer-name) ;; and continue...
    ;;        (message "aborting...")
    ;;        (return)))
    ;;       (let ((buf (get-buffer-create buffer-name)))
    ;;      ;; init new "EDITING" buffer as playlist buffer
    ;;      (with-current-buffer buf
    ;;        (emms-playlist-mode)
    ;;        (setq emms-playlist-buffer-p t))
    ;;      ;; update metaplaylist
    ;;      (emms-metaplaylist-mode-go)
    ;;      (emms-metaplaylist-mode-update)
    ;;      ;; go to new buffer
    ;;      (switch-to-buffer
    ;;       (emms-playlist-set-playlist-buffer buf))
    ;;      ;; select playlist file
    ;;      (let ((file (read-file-name "Playlist file: "
    ;;                                  emms-source-file-default-directory
    ;;                                  emms-source-file-default-directory
    ;;                                  t)))
    ;;        ;; add files
    ;;        (emms-add-playlist file)
    ;;        (setq emms-playlist-editor--current-path file)
    ;;        ))))

    ;;   (defun emms-playlist-editor-save-playlist ()
    ;;     (interactive)
    ;;     (let* ((buffer-name emms-playlist-editor--buffer-name)
    ;;         (buffer-real (get-buffer buffer-name))
    ;;         (path emms-playlist-editor--current-path))
    ;;       (if (not buffer-real)
    ;;        (message "Buffer \"%s\" doesn't exist, exiting..." buffer-name)
    ;;      (switch-to-buffer
    ;;       (emms-playlist-set-playlist-buffer buffer-real))
    ;;      ;; save to file
    ;;      (let ((format
    ;;             (emms-source-playlist-read-format)))
    ;;        (emms-playlist-save format path))


    ;;      )))

    ;; PLAYLISTS buffer, where i keep playlist files, autoload all

;;;;;;;;; YKW, fuck it, im just gonna tag everything in info-note (WORKS!)
    ;; filter by note with emms-playlist-limit-to-info-note
    ;; e.g. :nice:hardcore:

    ;; (emms-browser-add-category "note" 'info-note)
    (defun emms-browser-search-by-note ()
      (interactive)
      (emms-browser-search '(info-note)))

  ;;; As for playlists, i'll still be making it for, well, when i wanna make playlists,
    ;; but i wont need to rely on those special custom functions. i can suffice with just:
    ;; - `emms-add-playlist-file' (add playlist file) [maybe i should automate creating a PLAYLISTS buffer]
    ;; - `emms-playlist-mode-load-playlist' (expand playlist file in new playlist buffer)
    ;; - C-x C-s or `emms-playlist-save' (save playlist to file)
    ;; - `rename-buffer' (rename buffer to liking)
    ;;
    ;; TODO: bind the above to keybinds


  ;;; Holy shit writing my emacs config modules in a declarative org file is actually pretty realistic and doable!?!
    ;; It'll make everything so much nicer... documentation as well...

    (defvar emms-playlistedit-orig-path nil
      "A local var for playlist buffers with the path to its playlist file.")

    ;; emms-playlistedit-open : given a path to the playlist file, adds the playlist file to the "PLAYLISTS" buffer, load playlist in a new generic playlist buffer, with a buffer-local variable for orig path set (or maybe the playlist file?),
    ;; - simplify by adding the playlist file to a "PLAYLISTS" buffer, then loading it from there?
    (defun emms-playlistedit-playlist-file-edit ()
      "Given a loaded playlist file at point, load in a new playlist buffer for editing.
It's essentially the same as `emms-playlist-mode-load-playlist' but it also sets
a buffer-local variable `emms-playlistedit-orig-path'."
      (interactive)
      ;; load the playlist at point
      ;; (below is a copy of `emms-playlist-mode-load-playlist' (we want to use the `name' variable later)).
      (let* ((track (emms-playlist-track-at))
             (name (emms-track-get track 'name)))
        (emms-playlist-select (point))
        (run-hooks 'emms-player-stopped-hook)
        (switch-to-buffer
         (emms-playlist-set-playlist-buffer (emms-playlist-new)))
        (emms-add-playlist name)
        ;; let the buffer-local variable to be `name' and also rename.
        (let ((buf emms-playlist-buffer))
          (with-current-buffer buf
            (setq-local emms-playlistedit-orig-path name)
            (rename-buffer (concat (buffer-name)
                                   " : "
                                   name))))))

    ;; (defun emms-playlistedit-create-playlist-buffer (buffer-name)
    ;;     "Creates a new playlist buffer BUFFER-NAME.
    ;; Basically the same as `emms-metaplaylist-mode-new-buffer' but without switching
    ;; to the metaplaylist view."
    ;;     (interactive "sBuffer Name: ")
    ;;     (if (get-buffer buffer-name)
    ;;      (error "Buffer must not exist.")
    ;;       (let ((buf (get-buffer-create buffer-name)))
    ;;      (with-current-buffer buf
    ;;        (emms-playlist-mode)
    ;;        (setq emms-playlist-buffer-p t)))
    ;;       (emms-metaplaylist-mode-go)
    ;;       (emms-metaplaylist-mode-update)))

    ;; (defun emms-playlistedit-open-playlist-file ()
    ;;     "Creates a new playlist buffer from a playlist-file, saving the original path.
    ;; The original path is saved in a buffer-local variable."
    ;;     )

    ;; emms-playlistedit-goto-playlist-buffer : goes to the "PLAYLISTS" buffer. If not exist, create new then go to.

    ;;


    ;; - load playlist contents in a new playlist buffer
    ;;   - use a buffer-local variable for the origin path
    ;; - make changes
    ;; - emms-playlist-diff-and-save
    ;;   - if the buffer-local variable is nil, then just do emms-playlist-save as usual
    ;;   - if the buffer-local variable is set, then:
    ;;     - load the original playlist in "TMP-%s", and diff compare new and old playlists. (error if path to playlist invalid).
    ;;     - proceed?
    ;;       - if yes, overwrite playlist file with new changes, then delete "TMP-%s".
    ;;       - if no, delete "TMP-%s" and cancel.



    ;; maybe switch to mpv (mpd is too jank) (usempvScripts.mpris)

    )
  (leader-bind
    "e" '(:ignore t :wk "emms")
    "e e" 'emms
    "e k" 'emms-playlist-current-kill

    ;; goto
    "e p" 'emms-playlist-mode-go
    "e m" 'emms-metaplaylist-mode-go

    ;; browse
    "e B" 'emms-smart-browse
    "e b" '(:ignore t :wk "browse")
    "e b b" 'emms-browser
    "e b a" 'emms-browse-by-album
    "e b A" 'emms-browse-by-artist

    ;; control
    "e c" '(:ignore t :wk "control")
    "e c P" 'emms-pause
    "e c n" 'emms-next
    "e c p" 'emms-previous
    "e c s" 'emms-seek-to

    ;; info
    "e i" '(:ignore t :wk "info")
    "e i i" 'emms-show
    "e i a" 'emms-show-all
    "e i m" 'emms-player-mpd-show

    ;; sort
    "e S" '(:ignore t :wk "sort")
    "e S n" 'emms-playlist-sort-by-natural-order
    "e S r" 'emms-playlist-sort-by-random
    "e S o" 'emms-playlist-sort-by-info-note))

;; Sample config:
;; https://protesilaos.com/emacs/denote#h:5d16932d-4f7b-493d-8e6a-e5c396b15fd6

;; TODO: to look into!!
;; - https://baty.blog/2022/keeping-my-org-agenda-updated
;; - https://forum.systemcrafters.net/t/bring-denote-into-org-agenda-with-prettyness/779
;; https://www.reddit.com/r/emacs/comments/1er9wj4/denote_and_agenda_practical_use/

;; Note:
;; - dired: "% m" then "t" then `k' to kill and filter down results

(-setup denote
  (leader-bind
    "n" '(:ignore t :wk "denote")
    "nn" 'denote
    "ns" 'denote-subdirectory
    ;; "nf" 'denote-open-or-create ;; moved to consult-notes

    ;; renaming
    "nr" '(:ignore t :wk "rename file")
    "nrf" '(denote-rename-file :wk "rename file")
    "nrt" '(denote-rename-file-title :wk "rename title")
    "nrk" '(denote-rename-file-keywords :wk "rename keywords")

    ;; dired
    "nd" '(:ignore t :wk "dired")
    "ndj" '(+denote-directory-jump :wk "jump to denote dir")
    "ndr" '(denote-dired-rename-marked-files :wk "marked rename")
    "ndk" '(denote-dired-rename-marked-files-add-keywords
            :wk "marked add keywords")
    "ndK" '(denote-dired-rename-marked-files-remove-keywords
            :wk "marked remove keywords")

    ;; links
    "nl" '(:ignore t :wk "links")
    "nll" '(denote-find-link :wk "find links in file")
    "nln" '(denote-link :wk "new link")
    "nla" '(denote-add-links :wk "add links for metanote")

    ;; backlinks
    "nb" '(:ignore t :wk "backlinks")
    "nbb" '(denote-find-backlink :wk "find backlinks")
    "nbl" '(denote-backlinks :wk "list backlinks")

    ;; org-dblocks
    "no" '(:ignore t :wk "org-dblocks")
    "nol" '(denote-org-extras-dblock-insert-links :wk "dblock links")
    "nof" '(denote-org-extras-dblock-insert-files :wk "dblock files")
    "nob" '(denote-org-extras-dblock-insert-backlinks :wk "dblock backlinks")
    "noa" '(+denote-insert-file-local-dblock-update-mode :wk "insert file-local dblock mode")
    )

  (:when-loaded

    ;; variables
    (setq denote-directory (expand-file-name "~/Notes/denote"))
    (setq denote-known-keywords '("emacs" "meta"
                                  "art" "hobbies" "ideas"
                                  "class" "todo"
                                  "calc1" "arthist"
                                  "systemsoftware" "bio2"
                                  "random"))
    (setq denote-prompts '(title keywords subdirectory))
    (setq denote-save-buffers t)
    (setq denote-excluded-directories-regexp
          (concat
           ;; (^|/) ... (/|$)
           "\\(^\\|/\\)" "[aA]rchived?" "\\(/\\|$\\)" "\\|"
           "\\(^\\|/\\)" "[eE]xcluded?" "\\(/\\|$\\)" "\\|"
           "\\(^\\|/\\)" "_.*"          "\\(/\\|$\\)"))

    ;; when renaming, don't prompt for modify-file-name
    (setq denote-rename-confirmations '(rewrite-front-matter))

    ;; prettify

    ;; rename buffer/mode-line
    (setq denote-rename-buffer-format "%t%b %k")
    ;; (setq denote-rename-buffer-format "%D")
    (setq denote-rename-buffer-backlinks-indicator " :")
    (setq denote-buffer-name-prefix "<D> ")
    (denote-rename-buffer-mode 1)

    ;; dired fontify
    (add-hook 'dired-mode-hook #'denote-dired-mode)

    ;; links in text files
    (add-hook 'text-mode-hook #'denote-fontify-links-mode-maybe)

    ;; other

    (defun +denote-directory-jump ()
      (interactive)
      (dired denote-directory))

    ;; org-capture

    (with-eval-after-load 'org-capture
      (add-to-list 'org-capture-templates
                   '("n" "New note (with Denote)" plain
                     (file denote-last-path)
                     #'denote-org-capture
                     :no-save t
                     :immediate-finish nil
                     :kill-buffer t
                     :jump-to-captured t))))

  ;; org-dblocks

  ;; (define-minor-mode org-dblock-update-minor-mode
  ;;   "A minor mode that automatically updates Org mode dynamic blocks before saving."
  ;;   :lighter " OrgDBlocks"
  ;;   :global nil
  ;;   (if (and org-dblock-update-minor-mode (eq major-mode 'org-mode))
  ;;    (add-hook 'before-save-hook #'org-update-all-dblocks nil t)
  ;;     (remove-hook 'before-save-hook #'org-update-all-dblocks t)))

  ;; (defun +denote-insert-file-local-dblock-update-mode ()
  ;;   (interactive)
  ;;   (if (eq major-mode 'org-mode)
  ;;    (add-file-local-variable
  ;;     'eval
  ;;     '(org-dblock-update-minor-mode))
  ;;     (message "Not in an org-mode buffer")))

  ;; journal

  ;; (require 'denote-journal-extras)
  ;; (setq denote-journal-extras-directory
  ;;       (expand-file-name "journal" denote-directory))
  )

(-setup denote-journal
  (:load-after denote)
  (leader-bind
    ;; journal

    "nj" '(:ignore t :wk "journal")
    "njN" 'denote-journal-new-entry
    "njc" 'denote-journal-link-or-create-entry
    "njn" 'denote-journal-new-or-existing-entry))

;; provides consult sources:
;; - "SPC D" for denote buffers
;; - "SPC S" for denote subdirectories
(-setup consult-denote
  (:load-after consult-notes)
  (consult-denote-mode 1))
;; TODO: write my own consult function for "SPC S".


;; Docs: https://github.com/mclear-tools/consult-notes
(-setup consult-notes
  (:autoload consult-notes consult-notes-search-in-all-notes)
  (:load-after org)
  (:global "M-s n" consult-notes)
  (leader-bind
    "nf" 'consult-notes
    "ng" 'consult-notes-search-in-all-notes)
  (:when-loaded
    :config
    ;; denote keywords "_" fix
    (progn
      (setq consult-notes-denote-display-keywords-indicator "_")
      (defun consult-notes-denote--display-keywords (keywords)
        (format "%18s" (if keywords
                           (concat
                            consult-notes-denote-display-keywords-indicator
                            (mapconcat 'identity keywords "_"))
                         ""))))
    ;; custom printing format
    (progn
      (defun +consult-notes--file-dir-annotate (name dir cand)
        "Annotate file CAND with its directory DIR, size, and modification time."
        (let* ((file  (concat (file-name-as-directory dir) cand))
               (dirs  (abbreviate-file-name dir))
               (attrs (file-attributes file))
               (fsize (file-size-human-readable (file-attribute-size attrs)))
               (ftime (consult-notes--time (file-attribute-modification-time attrs))))
          (message "DEBUGGGGG: %s %s %s" file name dirs)
          (put-text-property 0 (length name)  'face 'consult-notes-name name)
          (put-text-property 0 (length dirs)  'face 'consult-notes-name dirs)
          (put-text-property 0 (length fsize) 'face 'consult-notes-size fsize)
          (put-text-property 0 (length ftime) 'face 'consult-notes-time ftime)
          (format "%7s %8s  %12s  %8s" name fsize ftime dirs)))
      (setq consult-notes-file-dir-annotate-function #'+consult-notes--file-dir-annotate))
    ;; enable for denote after load denote
    (with-eval-after-load 'denote
      (consult-notes-denote-mode 1))))

;; docs: https://lucidmanager.org/productivity/denote-explore/
(-setup denote-explore
  (:load-after denote)
  (leader-bind
    "ne" '(:ignore t :wk "explore")

    ;; random walks
    "new" '(:ignore t :wk "random walks")
    "newl" '(denote-explore-random-link :wk "random link")
    "newr" '(denote-explore-random-regex :wk "random regex")
    "newk" '(denote-explore-random-keyword :wk "random keyword")

    ;; janitor
    "nej" '(:ignore t :wk "janitor")
    "nejj" '(denote-explore-sync-metadata :wk "sync filenames from metadata")
    "nejm" '(denote-explore-sync-metadata :wk "sync filenames from metadata")
    "nejs" '(denote-explore-sort-keywords :wk "sort order of all keywords")
    "nejr" '(denote-explore-rename-keyword :wk "rename keyword")
    "nej0" '(denote-explore-zero-keywords :wk "0 keywords")
    "nej1" '(denote-explore-single-keywords :wk "1 keywords")

    ;; visualize
    "nen" '(:ignore t :wk "network")
    "nenn" '(denote-explore-network :wk "network")
    "nenr" '(denote-explore-network-regenerate :wk "network regenerate")
    "nend" '(denote-explore-degree-barchart :wk "degree barchart")

    ;; stats
    "nes" '(:ignore t :wk "stats")
    "nesk" '(denote-explore-barchart-keywords :wk "barchart keywords")
    "nese" '(denote-explore-barchart-filetypes :wk "barchart filetypes"))

  ;; :config
  ;; (setq denote-explore-network-format )
  ;; TODO: make denote-explore-network / browse-url-browser-function

  )

;; denote-menu
(-setup denote-menu
  (:load-after denote)
  (leader-bind
    "nm" 'list-denotes)
  (:with-map denote-menu-mode-map
    (:bind "c" denote-menu-clear-filters
           "r" denote-menu-filter
           "k" denote-menu-filter-by-keyword
           "o" denote-menu-filter-out-keyword
           "/ r" denote-menu-filter
           "/ k" denote-menu-filter-by-keyword
           "/ o" denote-menu-filter-out-keyword
           "e" denote-menu-export-to-dired))
  (:option denote-menu-title-column-width 50))

;;; set common keys
;; (leader-bind
;;   "nN" '(:ignore t :wk "Favorites")
;;   "nNn" 'denote
;;   "")
#+end_src
