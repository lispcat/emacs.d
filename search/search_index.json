{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This site contains my full Emacs configuration and its thorough documentation. Last updated: August 5, 2025","title":"Home"},{"location":"#home","text":"This site contains my full Emacs configuration and its thorough documentation. Last updated: August 5, 2025","title":"Home"},{"location":"about/","text":"About Why Emacs? Emacs is more than just a text editor. It's essentially a hacker's Swiss army knife with an infinite number of slots for new tools to add. What i use it for To list a few: IDE/text editing file management terminal pdf viewer note-taking obsidian-like \"second brain\" note-taking music player calculator calendar + scheduler/agenda Notable features Some neat features of my setup: Helix/Kakoune-like modal editing Elpaca package manager for asynchronous, non-blocking installations License This project is licensed under the GPL3 License. See the LICENSE file for details. Acknowledgements Last updated: August 6, 2025","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"build/early-init/","text":"early-init - Author: lispcat 187922791+lispcat@users.noreply.github.com The first file loaded at startup, automatically. At load-time, the Emacs GUI is yet to be created, so here we disable and modify GUI elements, as well as define path variables that will be used throughout the rest of the config. Code vars Pivotal vars to set first: ;; Here we set pivotal variables, such as setting the garbage collection ;; frequency, disabling autoload for the default package manager (to opt in for ;; a different one), and etc. ;; set startup gc ( setq gc-cons-threshold ( * 50 1000 1000 )) ;; dont load package.el ( setq package-enable-at-startup nil ) Directory Vars : defvar: ;; Here we define various path variables. ;; - root-dir: root of the Emacs config directory (usually \"~/.emacs.d/\"). ;; - src-dir: modularized config files; contains most of my config. ;; - local-dir: the root of the Emacs config directory, as Emacs and its ;; installed packages understands it to be (more on this later). ;; - submodules-dir: contains git submodules. ;; - config-file: the main config file, mostly used for accessibility purposes ;; (e.g. a command to open the main config file). ( defvar +emacs-root-dir ( file-name-as-directory ;; add trailing slash ( expand-file-name user-emacs-directory))) ( defvar +emacs-src-dir ( file-name-as-directory ( expand-file-name \"src\" +emacs-root-dir))) ( defvar +emacs-local-dir ( file-name-as-directory ( expand-file-name \"local\" +emacs-root-dir))) ( defvar +emacs-submodules-dir ( file-name-as-directory ( expand-file-name \"submodules\" +emacs-root-dir))) ( defvar +emacs-config-file ( directory-file-name ;; remove trailing slash ( expand-file-name \"init.el\" +emacs-root-dir))) Directory Vars : setq: ;; More on the local-dir: ;; - By default, Emacs throws temp and state files into ;; the `user-emacs-directory', or the root of the configuration directory. ;; This can get pretty messy, so we set the user-emacs-directory to a ;; subdirectory, the local-dir from earlier. ;; The custom-file: ;; - Any customizations saved using Emacs' \"customize\" interface will be added ;; to the `custom-file'. This file is later loaded in init.el. ;; set main dir to local dir ( setq user-emacs-directory +emacs-local-dir) ;; set custom-file location ( setq custom-file ( expand-file-name \"custom-vars.el\" +emacs-local-dir)) eln-cache dir - set to ./local/var/eln-cache ;; The eln-cache dir contains compiled .el files (.eln). ;; To keep the emacs-root-dir tidy, we override this path. ;; only works on Emacs 29 ( when ( and ( fboundp 'startup-redirect-eln-cache ) ( fboundp 'native-comp-available-p ) (native-comp-available-p)) (startup-redirect-eln-cache (convert-standard-filename ( expand-file-name \"var/eln-cache/\" +emacs-local-dir)))) UI GUI ;; The Emacs GUI has a lot of bloat by default, so they're disabled here (e.g. ;; tool-bar, menu-bar, scroll-bar). ;; These UI elements are typically loaded right after early-init.el loads, so ;; we disable them now. ;; disable tool-bar-setup (advice-add 'tool-bar-setup :override #' ignore) ;; UI disables ( setq tool-bar-mode nil ; disable tool bar menu-bar-mode nil ; disable menu bar scroll-bar-mode nil ) ; disable vertical scroll bar ;; UI tweaks ( setq default-frame-alist ' ((tool-bar-lines . 0 ) ; disable tool bar (menu-bar-lines . 0 ) ; disable menu bar (vertical-scroll-bars) ; disable vertical scroll bar (drag-internal-border . t ) ;; (internal-border-width . 13) ; box border around buffer+modeline (creates gap) (prev: 15) (fullscreen . maximized) ; TODO: ??? (left-fringe) ; set left fringe (right-fringe) ; set right fringe )) transparency ;; We enable transparency by default by adding an entry to default-frame-alist, ;; unless an entry for it already exists. ( let ((value 95 )) ( unless ( assoc 'alpha-background default-frame-alist) (add-to-list 'default-frame-alist ` (alpha-background . , value)))) ;; TODO: what is this??? ;; make initial frame invisible (note: requires (make-frame-visible) after theme ;; load) ;; (push '(visibility . nil) initial-frame-alist) default background color ;; In some display environments, during startup, Emacs will show its window. ;; During this period, a theme will yet to be set. So it will show the default ;; theme (white, flashbang), so this entry to default-frame-alist will set this ;; default background color to black. ;; use color black for startup frame ;; TODO: broken ;; (add-to-list 'default-frame-alist ;; '(background-color . \"#999999\")) misc lsp ;; Some tweaks for lsp-mode to increase performance. ;; https://emacs-lsp.github.io/lsp-mode/page/performance/#use-plists-for-deserialization (setenv \"LSP_USE_PLISTS\" \"true\" ) ( setq lsp-use-plists t ) end Last updated: { git_revision_date_localized }","title":"early-init"},{"location":"build/early-init/#early-init-","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com The first file loaded at startup, automatically. At load-time, the Emacs GUI is yet to be created, so here we disable and modify GUI elements, as well as define path variables that will be used throughout the rest of the config.","title":"early-init -"},{"location":"build/early-init/#code","text":"","title":"Code"},{"location":"build/init/","text":"init - the main init file Author: lispcat 187922791+lispcat@users.noreply.github.com The main init file. This is automatically ran at startup after early-init.el. Code Vars ;; Set various vars for sane defaults. ;; run .el instead of .elc if newer ( setq load-prefer-newer t ) ;; silence compiler warnings ( setq native-comp-async-report-warnings-errors nil ) no-littering ( progn ;; no-littering ;; manually add (add-to-list 'load-path (file-name-concat +emacs-submodules-dir \"no-littering\" )) ( require 'no-littering ) ;; variables ( setq auto-save-default nil ) ; don't autosave all file buffers ( setq backup-by-copying t ) ; safer backups ( setq undo-tree-auto-save-history nil ) ;; Dont litter project folders with backup files ( let ((backup-dir (no-littering-expand-var-file-name \"backup/\" ))) (make-directory backup-dir t ) ( setq backup-directory-alist ` (( \"\\\\`/tmp/\" . nil ) ( \"\\\\`/dev/shm/\" . nil ) ( \".\" . , backup-dir)))) ;; Tidy up auto-save files ( let ((auto-save-dir (no-littering-expand-var-file-name \"auto-save/\" ))) (make-directory auto-save-dir t ) ( setq auto-save-file-name-transforms ` (( \"\\\\`/[^/]*:\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)\\\\'\" , ( concat ( file-name-as-directory temporary-file-directory) \"\\\\2\" ) t ) ( \"\\\\`/tmp\\\\([^/]*/\\\\)*\\\\(.*\\\\)\\\\'\" \"\\\\2\" ) ( \"\\\\`/dev/shm\\\\([^/]*/\\\\)*\\\\(.*\\\\)\\\\'\" \"\\\\2\" ) ( \".\" , auto-save-dir t ))))) elpaca ;; elpaca 0.11 ( progn ( defvar elpaca-installer-version 0.11 ) ( defvar elpaca-directory ( expand-file-name \"elpaca/\" user-emacs-directory)) ( defvar elpaca-builds-directory ( expand-file-name \"builds/\" elpaca-directory)) ( defvar elpaca-repos-directory ( expand-file-name \"repos/\" elpaca-directory)) ( defvar elpaca-order ' (elpaca :repo \"https://github.com/progfolio/elpaca.git\" :ref nil :depth 1 :inherit ignore :files ( :defaults \"elpaca-test.el\" ( :exclude \"extensions\" )) :build ( :not elpaca--activate-package))) ( let* ((repo ( expand-file-name \"elpaca/\" elpaca-repos-directory)) (build ( expand-file-name \"elpaca/\" elpaca-builds-directory)) (order ( cdr elpaca-order)) (default-directory repo)) (add-to-list 'load-path ( if ( file-exists-p build) build repo)) ( unless ( file-exists-p repo) (make-directory repo t ) ( when ( <= emacs-major-version 28 ) ( require 'subr-x )) ( condition-case-unless-debug err (if-let* ((buffer (pop-to-buffer-same-window \"*elpaca-bootstrap*\" )) ((zerop ( apply #'call-process ` ( \"git\" nil , buffer t \"clone\" ,@ (when-let* ((depth ( plist-get order :depth ))) ( list ( format \"--depth=%d\" depth) \"--no-single-branch\" )) , ( plist-get order :repo ) , repo)))) ((zerop ( call-process \"git\" nil buffer t \"checkout\" ( or ( plist-get order :ref ) \"--\" )))) (emacs ( concat invocation-directory invocation-name )) ((zerop ( call-process emacs nil buffer nil \"-Q\" \"-L\" \".\" \"--batch\" \"--eval\" \"(byte-recompile-directory \\\".\\\" 0 'force)\" ))) (( require 'elpaca )) ((elpaca-generate-autoloads \"elpaca\" repo))) ( progn ( message \"%s\" ( buffer-string )) ( kill-buffer buffer)) ( error \"%s\" ( with-current-buffer buffer ( buffer-string )))) (( error ) ( warn \"%s\" err) (delete-directory repo 'recursive )))) ( unless ( require 'elpaca-autoloads nil t ) ( require 'elpaca ) (elpaca-generate-autoloads \"elpaca\" repo) ( let ((load-source-file-function nil )) ( load \"./elpaca-autoloads\" )))) (add-hook 'after-init-hook #' elpaca-process-queues) (elpaca ` ( ,@ elpaca-order))) ;; install use-package (elpaca elpaca-use-package (elpaca-use-package-mode) ( setq use-package-always-ensure t ) ( setq use-package-always-defer t )) ;; hack: exclude all externally installed packages from elpaca. ( progn ( require 'elpaca ) ( require 'cl-lib ) ( eval-when-compile ( require 'subr-x )) ;; is this ok? ( defun +elpaca-get-external-pkgs () \"Based on `package-load-all-descriptors' .\" ( let ((pkg-dir-lst nil ) (res nil )) ( dolist (dir ( cons package-user-dir package-directory-list)) ( when ( file-directory-p dir) ( dolist (pkg-dir ( directory-files dir t \"\\\\`[^.]\" )) ( when ( file-directory-p pkg-dir) ( push pkg-dir pkg-dir-lst))))) ( dolist (pkg-dir pkg-dir-lst) ( let ((pkg-file ( expand-file-name (package--description-file pkg-dir) pkg-dir)) (signed-file ( concat pkg-dir \".signed\" ))) ( when ( file-exists-p pkg-file) ( with-temp-buffer ( insert-file-contents pkg-file) ( goto-char ( point-min )) ( let ((pkg-text ( read ( current-buffer )))) ( if (not ( eq 'define-package ( car-safe pkg-text))) ( error \"Package %s doesn't have \\\"define-package\\\"\" pkg-file) ( let ((name (cadr pkg-text))) ( when name ( cl-pushnew ( intern name) res))))))))) res)) ( dolist (pkg (+elpaca-get-external-pkgs)) ( push pkg elpaca-ignored-dependencies))) leaf (elpaca leaf :wait ; deferred by default. demand with :leaf-defer nil ) (elpaca leaf-keywords (leaf-keywords-init) ( setq leaf-alias-keyword-alist ' (( :ensure . :elpaca ))) ( setq leaf-defaults ( append ' ( :ensure t ) leaf-system-defaults)) :wait ) ;; hack: fix org version mismatch (elpaca org) necessary packages ( use-package general :ensure ( :wait t ) :demand t :config (general-create-definer general-my-map :prefix \"C-c\" )) ( use-package diminish :ensure ( :wait t ) :demand t ) ( use-package which-key :ensure ( :wait t ) :demand t :diminish which-key-mode :config ( setq which-key-idle-delay 0.3 ) (which-key-mode 1 )) ( use-package hydra :ensure ( :wait t ) :demand t ) ( use-package dash :ensure ( :wait t ) :demand t :config ( defun -debug (label) \"Debugging helper function for dash.el.\" ( lambda (m) ( message \"%s: %S\" label m) m))) ( require 'cl-lib ) load-path adding to the load-path ;; load-path': ;; - A variable; a list of paths. ;; - Paths to search for when loading an elisp file (like with require'). ;; - Typically, for every elisp package, you add its root dir to this list so ;; that its main .el file is visible, and thus loadable. ;; - To make adding paths to this variable easier, we define the following ;; function. ( defun +add-to-load-path-recursively (path depth &optional exclude-self) \"Add PATH and its recursive subdirs to `load-path' . DEPTH specifies how deeply to recurse. 0 for just PATH, 1 for PATH and its subdirs, n>1 for till depth n, and -1 for infinite depth. If EXCLUDE-SELF is non-nil, exclude PATH, and include only its recursive subdirs. If PATH or a subdir contains a =.nosearch= file, it's excluded. This function returns a list of paths that were added to (or already exist in) `load-path' .\" ( cl-labels ( ;; return t if .nosearch file exists within dir (nosearch-subfile-p (d) ( file-exists-p ( expand-file-name \".nosearch\" d))) ;; collect recursive subdirs (collect-fn (current-dir current-depth) ( when ( and ( integerp current-depth) ;; base case (unless inf depth) ( /= current-depth 0 ) ( file-directory-p current-dir)) ( let ((subdirs (->> ( directory-files current-dir t directory-files-no-dot-files-regexp) (-filter #'file-directory-p ) (-remove #' nosearch-subfile-p)))) ;; collect [ subdirs + (recurse subdirs) ] (->> subdirs (-mapcat ( lambda (sub) (collect-fn sub ( 1- current-depth)))) ( append subdirs)))))) ( let* ((collected (collect-fn path depth)) (result ( if ( or exclude-self (nosearch-subfile-p path)) collected ( cons path collected)))) ;; add result to `load-path' (--each result (add-to-list 'load-path it)) result))) (+add-to-load-path-recursively +emacs-src-dir -1 ) (+add-to-load-path-recursively +emacs-submodules-dir 1 ) loading functions ;; require' ;; - A function that searches for and loads a corresponding elisp file from the ;; load-path'. ;; - Any files loaded with require' will be saved to the features' var, ;; so it can keep track of which files were loaded, prevent duplicate loads, ;; and manage dependencies. ;; - A side effect is that re-running require' with the same arg will do ;; nothing. ;; - By default, if it throws an error, it terminates Emacs initialization. To ;; prevent this, we write a wrapper +require' that catches any errors and ;; converts them into warnings. ;; load' ;; - A function similar to require', but with some key differences: ;; - Can take any arbitrary file path. ;; - Allows dupulicate loads. ;; - Does not add to the features' var. ;; - We make a wrapper +load' for this function as well. ;; A macro +require-or-load' is also defined, which runs +require' if not yet ;; loaded, and `+load' if already loaded. ( defmacro +require (feature &optional filename noerror) \"A wrapper around `require' to warn instead of error.\" ` ( progn ( condition-case-unless-debug err ( require , feature , filename , noerror) ( error (display-warning 'require ( format \"Failed to require: %s\" err) :error ))))) ( defmacro +load (file &optional noerror nomessage nosuffix must-suffix) \"A wrapper around `load' to warn instead of error.\" ` ( progn ( condition-case-unless-debug err ( load , file , noerror , nomessage , nosuffix , must-suffix) ( error (display-warning 'load ( format \"Failed to load: %s\" err) :error ))))) ( defmacro +require-or-load (feature) \"If FEATURE is loaded, run `+load' , Else, run `+require' .\" ` ( progn ( unless ( symbolp , feature) ( error \"Expected symbol, got: %S\" , feature)) ( if ( featurep , feature) (+load ( symbol-name , feature)) (+require , feature)))) startup hooks (add-hook 'emacs-startup-hook ( lambda () ( message \"*** Emacs loaded in %s seconds with %d garbage collections.\" (emacs-init-time \"%.2f\" ) gcs-done))) (add-hook 'elpaca-after-init-hook ( lambda () ( setq gc-cons-threshold ( * 10000 10000 )))) (add-hook 'elpaca-after-init-hook ( lambda () ( when ( file-exists-p custom-file) ( load custom-file)))) import ;; load ./src/src.el (+require-or-load 'src ) end Last updated: { git_revision_date_localized }","title":"init"},{"location":"build/init/#init-the-main-init-file","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com The main init file. This is automatically ran at startup after early-init.el.","title":"init - the main init file"},{"location":"build/init/#code","text":"","title":"Code"},{"location":"build/src/my-base/","text":"my-base - Author: lispcat 187922791+lispcat@users.noreply.github.com Code Last updated: { git_revision_date_localized }","title":"My base"},{"location":"build/src/my-base/#my-base-","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com","title":"my-base -"},{"location":"build/src/my-base/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-completion/","text":"? : corfu, kind-icon, wgrep?, consult-dir, cape ^ more at ~/code/cloned/daviwil-dots/.emacs.d/modules/dw-interface.el TODO: vim keybinds for vertico completion shit (work on later) (also daviwil) a framework for minibuffer completion (https://github.com/minad/vertico) Code Last updated: { git_revision_date_localized }","title":"My completion"},{"location":"build/src/my-completion/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-documentation/","text":"my-documentation - auto docs generator Author: lispcat 187922791+lispcat@users.noreply.github.com Automatically generates documentation using el2markdown. Converts elisp files into markdown docs. Code make package accessible (add-to-list 'load-path (file-name-concat +emacs-submodules-dir \"el2markdown-fork\" )) ( require 'el2markdown-fork ) ( require 'dash ) ( defun +remove-prefix-or-err (prefix str) ( if (string-prefix-p prefix str) (string-remove-prefix prefix str) ( error \"%s is not a prefix of %s\" prefix str) nil )) ( defun +zip-lists (list1 list2) ( let ((len1 ( length list1)) (len2 ( length list2))) ( unless ( eq len1 len2) ( error \"Lists to zip differ in length (%s %s): %s %s\" len1 len2 list1 list2)) (-zip-pair list1 list2))) ( defun +assert-f-dir-p (path) ( if (f-dir-p path) path ( error ( format \"Path not exist: %s\" path)) nil )) ( defun +create-docs (root-directory infiles-directory outfiles-directory &optional extra-infiles) ( interactive ( let* ((root-directory (read-file-name \"Root dir: \" default-directory `, ( buffer-file-name ) 'confirm )) (infiles-directory (read-file-name \"Infiles dir: \" root-directory nil 'confirm )) (outfiles-directory (read-file-name \"Outfiles dir: \" root-directory nil 'confirm ))) ;; ret ( list root-directory infiles-directory outfiles-directory))) ;; expand ( setq root-directory ( expand-file-name root-directory)) ( setq infiles-directory ( expand-file-name infiles-directory)) ( setq outfiles-directory ( expand-file-name outfiles-directory)) ( setq extra-infiles ( mapcar #'expand-file-name extra-infiles)) ;; fs checks (+remove-prefix-or-err root-directory infiles-directory) (+remove-prefix-or-err root-directory outfiles-directory) (+assert-f-dir-p root-directory) (+assert-f-dir-p infiles-directory) ;; proceed? ( when (y-or-n-p ( format \"Prefix: %s\\nInfiles: %s\\nOutfiles: %s\\n> Proceed? \" root-directory infiles-directory outfiles-directory)) ;; body ( let* ( ;; collect all infiles (infiles-all ( append ( reverse (-filter #'file-regular-p (directory-files-recursively infiles-directory emacs-lisp-file-regexp))) extra-infiles)) ;; derive all outfiles for each infile ;; - given infile: ;; - remove prefix infiles-directory, but keep the dirname ;; - replace extension .el -> .md ;; - prepend with prefix outfiles-directory (outfiles-all ( mapcar ( lambda (infile) (-as-> infile x (+remove-prefix-or-err ( file-name-directory infiles-directory) x) (file-name-sans-extension x) (file-name-with-extension x \".md\" ) ( expand-file-name x outfiles-directory))) infiles-all)) ;; create alist from infiles-all and outfiles-all (alist (+zip-lists infiles-all outfiles-all)) (alist-uniq-parts ( mapcar ( lambda (pair) ( let* ((infile ( car pair)) (outfile ( cdr pair)) (infile-uniq (+remove-prefix-or-err ( file-name-directory infiles-directory) infile)) (outfile-uniq (+remove-prefix-or-err outfiles-directory outfile)) (infile-uniq-no-slash (replace-regexp-in-string \"^/+\" \"\" infile-uniq)) (outfile-uniq-no-slash (replace-regexp-in-string \"^/+\" \"\" outfile-uniq))) ( cons infile-uniq-no-slash outfile-uniq-no-slash))) alist))) ; checks ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; check: ensure unique part (minus extension) is matching: ( dolist (pair alist-uniq-parts) ( unless ( equal (file-name-sans-extension ( car pair)) (file-name-sans-extension ( cdr pair))) ( error \"Found pair with non-equal uniq part: %s\" pair))) ;; check: ensure all infiles exist ( dolist (infile infiles-all) ( unless ( file-exists-p infile) ( error \"Found an infile that doesn't exist: %s\" infile))) ;; check: ensure all targets are under the outfiles dir: ( dolist (outfile outfiles-all) ( unless (+remove-prefix-or-err outfiles-directory outfile) ( error \"outfile not a prefix of outfiles-directory: %s\" outfile))) ;; delete outfiles-directory ( when (f-dir-p outfiles-directory) ( when (y-or-n-p ( format \"Trash outfiles-directory (%s)? \" outfiles-directory)) (move-file-to-trash outfiles-directory))) ;; action ( with-output-to-temp-buffer \"*File Copy Preview*\" ( princ \"Files to be copied:\\n\" ) ( princ \"==================\\n\\n\" ) ( dolist (pair alist) ( princ ( format \"%s\\n%s\\n\" ( car pair) ( cdr pair))))) ;; make all parent dirs? ( when (y-or-n-p ( format \"Create all parent dirs?\" )) ( dolist (path outfiles-all) ( message \"DEBUG: path: %s\" path) ( let ((dir ( file-name-directory path))) ( message \"DEBUG: dir: %s\" dir) ( unless (f-dir-p dir) (make-directory dir t ))))) ;; proceed? ( when (y-or-n-p \"Proceed?\" ) ( mapcar ( lambda (pair) ( let ((infile ( car pair)) (outfile ( cdr pair))) ( message \"%s\" pair) ( with-temp-buffer ( insert-file-contents infile) (el2markdown-write-file outfile t )))) alist))))) ( defun +create-docs-default () ( interactive ) (+create-docs \"~/.emacs.d/\" \"~/.emacs.d/src\" \"~/.emacs.d/docs/docs_src/build\" ' ( \"~/.emacs.d/init.el\" \"~/.emacs.d/early-init.el\" ))) end Last updated: { git_revision_date_localized }","title":"My documentation"},{"location":"build/src/my-documentation/#my-documentation-auto-docs-generator","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com Automatically generates documentation using el2markdown. Converts elisp files into markdown docs.","title":"my-documentation - auto docs generator"},{"location":"build/src/my-documentation/#code","text":"","title":"Code"},{"location":"build/src/my-ide/","text":"Code ( defvar prefer-lsp-mode? nil ) (auto-insert-mode) ;;; Adds hook to find-files-hook ( setq-default indent-tabs-mode nil ) ( setq tab-always-indent t ) (leaf compile :ensure nil :config ( setq compilation-scroll-output t )) (leaf flycheck :hook prog-mode-hook) (leaf emacs :ensure nil :hook goto-address-mode) (leaf project :ensure nil :bind-keymap ( \"C-c P\" . project-prefix-map) :init ( defun project-compile-interactive () ( declare (interactive-only compile)) ( interactive ) ( let ((current-prefix-arg ' ( 4 ))) ( call-interactively #' project-compile))) :bind (project-prefix-map ( \"C\" . project-compile-interactive))) (leaf projectile :init (projectile-mode 1 ) :bind-keymap ( \"C-c p\" . projectile-command-map) :config ( setq projectile-compile-use-comint-mode t )) (leaf lsp-mode :commands (lsp lsp-deferred) :hook (lsp-mode-hook . lsp-enable-which-key-integration) :bind-keymap ( \"C-c l\" . lsp-command-map) :config ( setq lsp-inlay-hint-enable t ;; freq of refreshing highlights, lenses, links, etc lsp-idle-delay 0.5 ;; bind \"C-c l\" to lsp-command-map lsp-keymap-prefix \"C-c l\" ;; problematic: https://github.com/emacs-lsp/lsp-mode/issues/4113 lsp-update-inlay-hints-on-scroll nil )) (leaf lsp-ui :bind (lsp-ui-mode-map ([remap xref-find-definitions] . lsp-ui-peek-find-definitions) ([remap xref-find-references] . lsp-ui-peek-find-references)) (lsp-ui-doc-frame-mode-map ( \"q\" . lsp-ui-doc-hide) ( \"u\" . lsp-ui-doc-unfocus-frame)) :config ( setq lsp-ui-doc-delay 0.5 lsp-ui-doc-position 'top ;; lsp-ui-doc-alignment 'window lsp-ui-doc-alignment 'frame ;; lsp-ui-doc-show-with-mouse nil lsp-ui-doc-show-with-mouse t lsp-ui-doc-show-with-cursor t lsp-ui-sideline-delay 0.2 lsp-ui-imenu-auto-refresh-delay 1.0 ) ( with-eval-after-load 'lsp-mode ( define-key lsp-command-map (kbd \"v i\" ) #' lsp-ui-imenu))) ;;; lsp-booster ;; use lsp-doctor for testing ;; Steps: ;; - install emacs-lsp-booster ;; - use plist for deserialization (FOLLOW GUIDE) (leaf emacs :ensure nil :config ( setq read-process-output-max ( * 1024 1024 )) ;; 1mb ( defun lsp-booster--advice-json-parse (old-fn &rest args) \"Try to parse bytecode instead of json.\" ( or ( when ( equal ( following-char ) ?# ) ( let ((bytecode ( read ( current-buffer )))) ( when ( byte-code-function-p bytecode) ( funcall bytecode)))) ( apply old-fn args))) (advice-add ( if ( progn ( require 'json ) ( fboundp 'json-parse-buffer )) 'json-parse-buffer 'json-read ) :around #' lsp-booster--advice-json-parse) ( defun lsp-booster--advice-final-command (old-fn cmd &optional test?) \"Prepend emacs-lsp-booster command to lsp CMD.\" ( let ((orig-result ( funcall old-fn cmd test?))) ( if ( and (not test?) ;; for check lsp-server-present? (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper lsp-use-plists (not ( functionp 'json-rpc-connection )) ;; native json-rpc (executable-find \"emacs-lsp-booster\" )) ( progn (when-let ((command-from-exec-path (executable-find ( car orig-result)))) ;; resolve command from exec-path (in case not found in $PATH) ( setcar orig-result command-from-exec-path)) ( message \"Using emacs-lsp-booster for %s!\" orig-result) ( cons \"emacs-lsp-booster\" orig-result)) orig-result))) (advice-add 'lsp-resolve-final-command :around #' lsp-booster--advice-final-command)) ;; for non-programming too (leaf elec-pair :ensure nil :require t :config ;; disable \"<\" pair expansion ( defun +disable-<-pair-expansion () ( setq-local electric-pair-inhibit-predicate ` ( lambda (c) ( if ( char-equal c ?< ) t ( , electric-pair-inhibit-predicate c))))) (add-hook 'org-mode-hook #' +disable-<-pair-expansion) ;; global (electric-pair-mode 1 )) langs ( setq +lisp-mode-hooks ' (emacs-lisp-mode-hook scheme-mode-hook)) ;; rainbow parens (leaf rainbow-delimiters :hook `,@ +lisp-mode-hooks) ;; paredit (leaf paredit :hook `,@ +lisp-mode-hooks) (leaf emacs :ensure nil :hook ((emacs-lisp-mode-hook . ( lambda () (auto-fill-mode) ( setq-local fill-column 80 ))))) (leaf orglink :hook emacs-lisp-mode-hook) ;; other ( defun create-banner-comment (text &optional width) \"Create a banner comment with TEXT centered between semicolons. Optional WIDTH parameter determines total width (defaults to 70).\" ( interactive \"sText: \" ) ( let* ((width ( or width 70 )) (text-len ( length text)) (semi-len ( / ( - width text-len 2 ) 2 )) ; -2 for spaces (left-semis ( make-string semi-len ?\\; )) (right-semis ( make-string ( if (cl-oddp ( - width text-len)) ( 1+ semi-len) semi-len) ?\\; ))) ( insert ( format \"%s %s %s\\n\" left-semis text right-semis)))) ( with-eval-after-load 'flycheck ( setq-default flycheck-disabled-checkers ' (emacs-lisp-checkdoc))) (leaf scheme-mode :ensure nil :disabled t :mode \"\\\\.sld\\\\'\" \"\\\\.scm\\\\'\" ) (leaf geiser :disabled t :mode \"\\\\.scm\\\\'\" :setq (geiser-default-implementation . 'guile ) (geiser-active-implementations . ' (guile)) (geiser-implementations-alist . ' (((regexp \"\\\\.scm$\" ) guile)))) (leaf geiser-guile :disabled t :after geiser) (leaf rust-mode :require t :init ( setq rust-mode-treesitter-derive t ) ( setq rust-rustfmt-switches ' ( \"--edition\" \"2021\" ))) (leaf rustic :require t :after rust-mode :config ( setq rustic-cargo-use-last-stored-arguments t ) ( setq rustic-format-on-save t ) ( setq rustic-rustfmt-args \"--edition 2021\" ) ;; lsp-mode settings ( with-eval-after-load 'lsp-mode ( setq lsp-rust-analyzer-cargo-watch-command \"clippy\" lsp-rust-analyzer-display-closure-return-type-hints t ; def: nil lsp-rust-analyzer-display-lifetime-elision-hints-enable \"skip_trivial\" lsp-rust-analyzer-display-parameter-hints t ; def: nil (input param name) ;; maybe ;; lsp-rust-analyzer-display-reborrow-hints \"mutable\" ; def: never (&*(&*jargon)) lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t ; def: nil (?) ;; experimenting lsp-signature-auto-activate t ; def: '(:on-trigger-char :on-server-request) )) ;; use tree-sitter for rustic-mode ;; (define-derived-mode rustic-mode rust-ts-mode \"Rustic\" ;; \"Major mode for Rust code. ;; \\\\{rustic-mode-map}\" ;; :group 'rustic ;; (when (bound-and-true-p rustic-cargo-auto-add-missing-dependencies) ;; (add-hook 'lsp-after-diagnostics-hook 'rustic-cargo-add-missing-dependencies-hook nil t))) :bind (rustic-mode-map ( \"C-c C-c M-r\" . rustic-cargo-comint-run) ( \"C-c C-c l\" . flycheck-list-errors) ( \"C-c C-c A\" . rustic-cargo-add) ( \"C-c C-c R\" . rustic-cargo-rm) ( \"C-c C-c a\" . lsp-execute-code-action) ( \"C-c C-c r\" . lsp-rename) ( \"C-c C-c q\" . lsp-workspace-restart) ( \"C-c C-c Q\" . lsp-workspace-shutdown) ( \"C-c C-c s\" . lsp-rust-analyzer-status) ( \"C-c C-c h\" . lsp-describe-thing-at-point)) :hook (rust-ts-mode-hook . ( lambda () ;; company settings ( with-eval-after-load 'company ( setq-local company-idle-delay 0.3 company-minimum-prefix-length 2 )) ;; lsp settings ( with-eval-after-load 'lsp-mode ( setq-local lsp-idle-delay 0.5 lsp-ui-sideline-delay 0.3 lsp-eldoc-render-all nil ; def: nil (minibuffer doc popup) lsp-ui-doc-enable t ; def: t (ui-popup docs) lsp-ui-doc-max-height 14 ; def: 13 ))))) ;; (leaf rustic :ensure nil ;; ;; :disabled t ;; :if use-eglot? ;; :init ;; (setq rustic-lsp-client 'eglot) ;; (with-eval-after-load 'eglot ;; (let ((rust-init-options ;; `( ;; :cargo ( :buildScripts (:enable t) :features \"all\" ) ;; :procMacro ( :enable t ) ;; :checkOnSave ( :command \"clippy\" ) ;; :inlayHints ( :typeHints t ;; :parameterHints t ;; :closureReturnTypeHints t ;; :lifetimeElisionHints (:enable \"skip_trivial\" :useParameterNames t) ;; :reborrowHints \"mutable\" ;; ;; :chainingHints t ;; ) ;; ))) ;; (add-to-list 'eglot-server-programs ;; `(rustic-mode . (\"rust-analyzer\" ;; :initializationOptions ,rust-init-options))))) ;; ;; :config ;; ) ;; rustowl ;; (straight-use-package ;; `(rustowlsp ;; :host github ;; :repo \"cordx56/rustowl\" ;; :files (:defaults \"emacs/*\"))) (leaf cc-mode :ensure nil :hook ((c-mode-hook . lsp) (c-mode-hook . ( lambda () ( setq-local lsp-idle-delay 0.1 lsp-enable-indentation nil lsp-enable-on-type-formatting nil ) (c-set-offset 'case-label '+ )))) :config (add-to-list 'c-default-style ' (c-mode . \"cc-mode\" )) ( define-key c-mode-map (kbd \"<f8>\" ) #' project-compile-interactive)) ;; (leaf cc-mode :ensure nil ;; :if use-eglot? ;; :hook ((c-mode-hook . eglot-ensure) ;; (c-mode-hook . (lambda () ;; ;; (setq-local lsp-idle-delay 0.1 ;; ;; lsp-enable-indentation nil ;; ;; lsp-enable-on-type-formatting nil) ;; (c-set-offset 'case-label '+)))) ;; :config ;; (add-to-list 'c-default-style '(c-mode . \"cc-mode\")) ;; (define-key c-mode-map (kbd \"<f8>\") #'project-compile-interactive)) (leaf lsp-java :mode \"\\\\.java\\\\'\" :config (add-hook 'java-mode-hook #' lsp)) ;; (leaf eglot-java ;; :hook java-mode-hook ;; :bind ;; (eglot-java-mode-map ;; (\"C-c l n\" . eglot-java-file-new) ;; (\"C-c l x\" . eglot-java-run-main) ;; (\"C-c l t\" . eglot-java-run-test) ;; (\"C-c l N\" . eglot-java-project-new) ;; (\"C-c l T\" . eglot-java-project-build-task) ;; (\"C-c l R\" . eglot-java-project-build-refresh))) (leaf markdown-mode :mode (( \"README\\\\.md\\\\'\" . gfm-mode) ( \"\\\\.md\\\\'\" . markdown-mode)) :setq (markdown-fontify-code-blocks-natively . t ) :config ( defun +setup-markdown-mode () ;; (visual-fill-column-mode 1) (display-line-numbers-mode 0 )) ;; (setq markdown-command \"marked\") (add-hook 'markdown-mode-hook #' +setup-markdown-mode)) (leaf clojure-mode :disabled t ) (leaf scala-mode :disabled t :interpreter \"scala\" :hook ( lambda () ( setq prettify-symbols-alist scala-prettify-symbols-alist))) (leaf zig-mode :disabled t ;; :config ;; (zig-format-on-save-mode 0) ) (leaf haskell-mode :mode \"\\\\.hs\\\\'\" ) (leaf nix-mode :mode \"\\\\.nix\\\\'\" :hook ((nix-mode-hook . lsp))) (leaf yaml-mode :mode \"\\\\.yml\\\\'\" ) (leaf ron-mode :require t ) (leaf emacs :ensure nil ;; kerolox! ;; Major-mode for .rp1 files ( define-derived-mode kerolox-mode prog-mode \"kerolox\" \"Major mode for editing kerolox (.rp1) files.\" :group 'kerolox ) ( with-eval-after-load 'lsp-mode ;; Register LSP server and setup LSP server (add-to-list 'lsp-language-id-configuration ' (kerolox-mode . \"kerolox\" )) (lsp-register-client (make-lsp-client :new-connection (lsp-stdio-connection ' ( \"/home/sui/Code/cloned/saturn-v/target/release/saturn-v\" \"lsp\" )) :major-modes ' (kerolox-mode) :server-id 'saturn-v-lsp ))) ;;;; Kerolox treesit mode and LSP ( define-derived-mode kerolox-ts-mode kerolox-mode \"kerolox[ts]\" \"Tree-sitter based major mode for editing kerolox (.rp1) files.\" :group 'kerolox ( when ( and ( fboundp 'treesit-available-p ) (treesit-available-p)) ;; create parser for this buffer (treesit-parser-create 'kerolox ) ( setq-local treesit-font-lock-feature-list ' ((comment) (keyword string ) (constant type) ( function variable module constructor) (operator punctuation))) ( setq-local font-lock-defaults nil ) ;; Set up face mapping for tree-sitter query capture names to Emacs faces ( defvar kerolox-ts-font-lock-settings (treesit-font-lock-rules :language 'kerolox :feature 'comment ' ((comment) @font-lock-comment-face) :language 'kerolox :feature 'constant ' ((integer) @font-lock-constant-face (value (symbol)) @font-lock-constant-face) :language 'kerolox :feature 'variable ' ((variable) @font-lock-variable-name-face) :language 'kerolox :feature 'module ' ((import (symbol)) @font-lock-preprocessor-face) :language 'kerolox :feature 'type ' ((type (symbol)) @font-lock-type-face) :language 'kerolox :feature 'function ' ((definition relation: (symbol)) @font-lock-function-name-face ( atom head: (symbol)) @font-lock-function-name-face) :language 'kerolox :feature 'constructor ' ((rule relation: (symbol)) @font-lock-function-name-face) :language 'kerolox :feature 'punctuation ' (([ \":-\" \",\" \".\" ]) @font-lock-delimiter-face ([ \"(\" \")\" ]) @font-lock-bracket-face) :language 'kerolox :feature 'operator ' ((binary_expr op: (_)) @font-lock-builtin-face (unary_expr op: (_)) @font-lock-builtin-face (cardinality kind: (_)) @font-lock-builtin-face) :language 'kerolox :feature 'keyword ' (([ \"constrain\" \"decision\" \"define\" \"import\" \"output\" \"soft\" ]) @font-lock-keyword-face (constraint_kind) @font-lock-keyword-face)) \"Font-lock settings for Kerolox.\" ) ;; Set font-lock settings from the defined rules ( setq-local treesit-font-lock-settings kerolox-ts-font-lock-settings) (treesit-major-mode-setup))) ;; Register LSP server and setup LSP server ( with-eval-after-load 'lsp-mode (add-to-list 'lsp-language-id-configuration ' (kerolox-ts-mode . \"kerolox\" )) (lsp-register-client (make-lsp-client :new-connection (lsp-stdio-connection ' ( \"/home/sui/Code/cloned/saturn-v/target/release/saturn-v\" \"lsp\" )) :major-modes ' (kerolox-ts-mode) :server-id 'saturn-v-ts-lsp ))) ;;;; Tree-sitter generic ;;;; ( with-eval-after-load 'treesit ;; Configure the language grammar source and mapping ( when ( and ( fboundp 'treesit-available-p ) (treesit-available-p)) ;; Define grammar source (add-to-list 'treesit-language-source-alist ' (kerolox . ( \"https://github.com/marceline-cramer/saturn-v\" nil \"tree-sitter-kerolox/src\" ))) ;; ;; Set up language mapping ;; (add-to-list 'treesit-language-remap-alist '(kerolox-ts-mode . kerolox)) ;; Only install if not already installed ;; (unless (treesit-language-available-p 'kerolox) ;; (treesit-install-language-grammar 'kerolox)) (treesit-install-language-grammar 'kerolox ) )) ;; Auto-start LSP when opening .rp1 files with tree-sitter mode (add-hook 'kerolox-ts-mode-hook #' lsp-deferred) ;;;; Misc ;;;; ;; Remap regular mode to tree-sitter mode ( setq major-mode-remap-alist ' ((kerolox-mode . kerolox-ts-mode))) ;;;; Auto-mode-alist ;;;; ;; Associate file name pattern with major-mode (add-to-list 'auto-mode-alist ' ( \"\\\\.rp1\\\\'\" . kerolox-ts-mode))) (leaf lua-mode :config ( with-eval-after-load 'lsp-lua ;; fix issue with externally installed server ( setq lsp-clients-lua-language-server-command \"lua-language-server\" ) ;; renoise lua api definitions ;; (setq lsp-lua-workspace-library \"'Lua.workspace.library': {'/home/sui/Music/prod/scripts/renoise-lua/definitions': true}\") ( setq lsp-lua-workspace-library (ht ( \"/home/sui/Music/prod/scripts/renoise-lua/definitions\" t ))) ( setq lsp-lua-runtime-plugin \"/home/sui/Music/prod/scripts/renoise-lua/definitions/plugin.lua\" ) ) ;; fix pt.2 ( defun +lsp-clients-lua-language-server-test () \"(Improved) Test Lua language server binaries and files.\" ( or ( and (f-exists? lsp-clients-lua-language-server-main-location) (f-exists? lsp-clients-lua-language-server-bin)) (f-exists? ( car (split-string lsp-clients-lua-language-server-command))))) (advice-add #' lsp-clients-lua-language-server-test :override #' +lsp-clients-lua-language-server-test)) (leaf direnv :init (direnv-mode 1 )) (leaf rainbow-mode :hook prog-mode-hook) ( with-eval-after-load 'ansi-color (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter )) (leaf treesit-auto :require t :config ( setq treesit-auto-install 'prompt ) (global-treesit-auto-mode)) Code formatting Last updated: { git_revision_date_localized }","title":"My ide"},{"location":"build/src/my-ide/#code","text":"( defvar prefer-lsp-mode? nil ) (auto-insert-mode) ;;; Adds hook to find-files-hook ( setq-default indent-tabs-mode nil ) ( setq tab-always-indent t ) (leaf compile :ensure nil :config ( setq compilation-scroll-output t )) (leaf flycheck :hook prog-mode-hook) (leaf emacs :ensure nil :hook goto-address-mode) (leaf project :ensure nil :bind-keymap ( \"C-c P\" . project-prefix-map) :init ( defun project-compile-interactive () ( declare (interactive-only compile)) ( interactive ) ( let ((current-prefix-arg ' ( 4 ))) ( call-interactively #' project-compile))) :bind (project-prefix-map ( \"C\" . project-compile-interactive))) (leaf projectile :init (projectile-mode 1 ) :bind-keymap ( \"C-c p\" . projectile-command-map) :config ( setq projectile-compile-use-comint-mode t )) (leaf lsp-mode :commands (lsp lsp-deferred) :hook (lsp-mode-hook . lsp-enable-which-key-integration) :bind-keymap ( \"C-c l\" . lsp-command-map) :config ( setq lsp-inlay-hint-enable t ;; freq of refreshing highlights, lenses, links, etc lsp-idle-delay 0.5 ;; bind \"C-c l\" to lsp-command-map lsp-keymap-prefix \"C-c l\" ;; problematic: https://github.com/emacs-lsp/lsp-mode/issues/4113 lsp-update-inlay-hints-on-scroll nil )) (leaf lsp-ui :bind (lsp-ui-mode-map ([remap xref-find-definitions] . lsp-ui-peek-find-definitions) ([remap xref-find-references] . lsp-ui-peek-find-references)) (lsp-ui-doc-frame-mode-map ( \"q\" . lsp-ui-doc-hide) ( \"u\" . lsp-ui-doc-unfocus-frame)) :config ( setq lsp-ui-doc-delay 0.5 lsp-ui-doc-position 'top ;; lsp-ui-doc-alignment 'window lsp-ui-doc-alignment 'frame ;; lsp-ui-doc-show-with-mouse nil lsp-ui-doc-show-with-mouse t lsp-ui-doc-show-with-cursor t lsp-ui-sideline-delay 0.2 lsp-ui-imenu-auto-refresh-delay 1.0 ) ( with-eval-after-load 'lsp-mode ( define-key lsp-command-map (kbd \"v i\" ) #' lsp-ui-imenu))) ;;; lsp-booster ;; use lsp-doctor for testing ;; Steps: ;; - install emacs-lsp-booster ;; - use plist for deserialization (FOLLOW GUIDE) (leaf emacs :ensure nil :config ( setq read-process-output-max ( * 1024 1024 )) ;; 1mb ( defun lsp-booster--advice-json-parse (old-fn &rest args) \"Try to parse bytecode instead of json.\" ( or ( when ( equal ( following-char ) ?# ) ( let ((bytecode ( read ( current-buffer )))) ( when ( byte-code-function-p bytecode) ( funcall bytecode)))) ( apply old-fn args))) (advice-add ( if ( progn ( require 'json ) ( fboundp 'json-parse-buffer )) 'json-parse-buffer 'json-read ) :around #' lsp-booster--advice-json-parse) ( defun lsp-booster--advice-final-command (old-fn cmd &optional test?) \"Prepend emacs-lsp-booster command to lsp CMD.\" ( let ((orig-result ( funcall old-fn cmd test?))) ( if ( and (not test?) ;; for check lsp-server-present? (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper lsp-use-plists (not ( functionp 'json-rpc-connection )) ;; native json-rpc (executable-find \"emacs-lsp-booster\" )) ( progn (when-let ((command-from-exec-path (executable-find ( car orig-result)))) ;; resolve command from exec-path (in case not found in $PATH) ( setcar orig-result command-from-exec-path)) ( message \"Using emacs-lsp-booster for %s!\" orig-result) ( cons \"emacs-lsp-booster\" orig-result)) orig-result))) (advice-add 'lsp-resolve-final-command :around #' lsp-booster--advice-final-command)) ;; for non-programming too (leaf elec-pair :ensure nil :require t :config ;; disable \"<\" pair expansion ( defun +disable-<-pair-expansion () ( setq-local electric-pair-inhibit-predicate ` ( lambda (c) ( if ( char-equal c ?< ) t ( , electric-pair-inhibit-predicate c))))) (add-hook 'org-mode-hook #' +disable-<-pair-expansion) ;; global (electric-pair-mode 1 ))","title":"Code"},{"location":"build/src/my-kbd/","text":"Actuates Meta key by default Code Last updated: { git_revision_date_localized }","title":"My kbd"},{"location":"build/src/my-kbd/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-latex/","text":"Code Last updated: { git_revision_date_localized }","title":"My latex"},{"location":"build/src/my-latex/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-misc/","text":"Code Last updated: { git_revision_date_localized }","title":"My misc"},{"location":"build/src/my-misc/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-org/","text":"my-org - org mode setup Author: lispcat 187922791+lispcat@users.noreply.github.com Code Last updated: { git_revision_date_localized }","title":"My org"},{"location":"build/src/my-org/#my-org-org-mode-setup","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com","title":"my-org - org mode setup"},{"location":"build/src/my-org/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-programs/","text":"Code Last updated: { git_revision_date_localized }","title":"My programs"},{"location":"build/src/my-programs/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-to-sort/","text":"Code Last updated: { git_revision_date_localized }","title":"My to sort"},{"location":"build/src/my-to-sort/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-ui/","text":"Code Last updated: { git_revision_date_localized }","title":"My ui"},{"location":"build/src/my-ui/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/my-workspaces/","text":"maybe have each persp have its own save file, and when autosaving, save each persp? maybe have a function to delete a persp from the main autosave file? - prompt available perspectives from main autosave file, after selection, delete each from file. Code Last updated: { git_revision_date_localized }","title":"My workspaces"},{"location":"build/src/my-workspaces/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/src/","text":"src - Author: lispcat 187922791+lispcat@users.noreply.github.com Code Last updated: { git_revision_date_localized }","title":"Src"},{"location":"build/src/src/#src-","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com","title":"src -"},{"location":"build/src/src/#code","text":"Last updated: { git_revision_date_localized }","title":"Code"},{"location":"build/src/misc/%2Blog/","text":"+log - logging functions Author: lispcat 187922791+lispcat@users.noreply.github.com logging functions Code post-init log src-dir state ;; ( require 'dash ) ( defun +log-src-dir-state () \"Returns paths under `+emacs-src-dir' that may be excluded from `load-path' . Intended to be ran post-initialization. Elisp files under the `+emacs-src-dir' must be manually loaded with `require' , typically from a single file. To catch possible files that should be loaded, but were not loaded, they're identified and logged using this function.\" ( let* ((matching-dirs (-some->> load-path ;; is elem from load-path under src-dir? exists? dir? (-filter (-andfn (-partial #'string-match +emacs-src-dir) #'file-exists-p #'file-directory-p )))) ;; debug (_ ( funcall (-debug \"Log: +emacs-src-dir: dirs found\" ) matching-dirs)) (elisp-files (-some->> matching-dirs ;; collect all subfiles (-mapcat ( lambda (f) ( directory-files f directory-files-no-dot-files-regexp))) ;; keep only elisp files (-filter (-partial #'string-match emacs-lisp-file-regexp)))) (valid-elisp-files (-some->> elisp-files ;; keep only valid/require-able files (-filter ( lambda (f) ( with-temp-buffer ( insert-file-contents f) ( goto-char ( point-min )) ( search-forward ( concat \"(provide '\" (file-name-base f) \")\" ) nil t )))))) ;; debug (_ ( funcall (-debug \"Log: +emacs-src-dir: invalid elisp files\" ) (-map #'file-name-nondirectory (-difference elisp-files valid-elisp-files)))) (remove-existing ;; remove files already require'd ( let ((removed-lst (-remove (-compose #'featurep #'intern #' file-name-base) valid-elisp-files))) ( if removed-lst ( message \"WARNING: +emacs-src-dir: non-loaded file: %s\" removed-lst) ( message \"Log: +emacs-src-dir: no issues\" )))) (result remove-existing)) ;; return mesg, or deal with nil ( or result ( message \"ERROR: +emacs-src-dir: error in logging func?\" )))) (add-hook 'emacs-startup-hook #' +log-src-dir-state) Last updated: { git_revision_date_localized }","title":"+log"},{"location":"build/src/misc/%2Blog/#log-logging-functions","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com logging functions","title":"+log - logging functions"},{"location":"build/src/misc/%2Blog/#code","text":"","title":"Code"},{"location":"build/src/misc/%2Btools/","text":"+tools - misc tools Author: lispcat 187922791+lispcat@users.noreply.github.com Code ( defun +benchmark-lambdas (f1 f2 &optional n) ( let* ((n ( or n 10000 )) (time1 ( car (benchmark-run n ( funcall f1)))) (time2 ( car (benchmark-run n ( funcall f2)))) (less ( if ( < time1 time2) \"f1\" \"f2\" )) (symbol ( if ( < time1 time2) \"<\" \">\" )) (difference ( if ( > time1 time2) ( - time1 time2) ( - time2 time1)))) ( message \"f1: %.6f %s f2: %.6f (%s faster by %.6f)\" time1 symbol time2 less difference))) end Last updated: { git_revision_date_localized }","title":"+tools"},{"location":"build/src/misc/%2Btools/#tools-misc-tools","text":"Author: lispcat 187922791+lispcat@users.noreply.github.com","title":"+tools - misc tools"},{"location":"build/src/misc/%2Btools/#code","text":"( defun +benchmark-lambdas (f1 f2 &optional n) ( let* ((n ( or n 10000 )) (time1 ( car (benchmark-run n ( funcall f1)))) (time2 ( car (benchmark-run n ( funcall f2)))) (less ( if ( < time1 time2) \"f1\" \"f2\" )) (symbol ( if ( < time1 time2) \"<\" \">\" )) (difference ( if ( > time1 time2) ( - time1 time2) ( - time2 time1)))) ( message \"f1: %.6f %s f2: %.6f (%s faster by %.6f)\" time1 symbol time2 less difference)))","title":"Code"}]}